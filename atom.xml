<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qingbiao&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-17T08:45:22.622Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>qingbiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown语法格式</title>
    <link href="http://yoursite.com/2019/03/17/Markdown%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/17/Markdown语法格式/</id>
    <published>2019-03-17T08:10:41.203Z</published>
    <updated>2019-03-17T08:45:22.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参照：<a href="https://help.github.com/en/categories/writing-on-github" target="_blank" rel="noopener">https://help.github.com/en/categories/writing-on-github</a></p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>要创建标题，就在文本前面添加1~6个<code>#</code>符号。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br></pre></td></tr></table></figure><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>将要使用粗体的文本用<code>**</code>包括。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**This is bold text**</span><br></pre></td></tr></table></figure><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>将要使用粗体的文本用<code>*</code>包括。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*This text is italicized*</span><br></pre></td></tr></table></figure><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>将要使用粗体的文本用<code>~~</code>包括。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~This was mistaken text~~</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用<code>&gt;</code>引用一段文本。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is quoting text</span><br></pre></td></tr></table></figure><h2 id="引用代码"><a href="#引用代码" class="headerlink" title="引用代码"></a>引用代码</h2><p>使用 ` 包括引用的代码行。</p><p>使用 ``` 包括引用的代码块。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\`This is the line of code\`</span><br><span class="line"></span><br><span class="line">\​`\`\`</span><br><span class="line">These are the code blocks</span><br><span class="line">These are the code blocks</span><br><span class="line">These are the code blocks</span><br><span class="line">​\`\`\`</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在方括号中包装链接文本<code>[ ]</code>，然后将URL包装在圆括号中来创建内联链接<code>( )</code>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [text](https://gqbbbb.github.io/).</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>把<code>-</code>或<code>*</code>放在行前来表示无序列表。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- George Washington</span><br><span class="line">- John Adams</span><br><span class="line">- Thomas Jefferson</span><br></pre></td></tr></table></figure><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>把<code>数字</code>+<code>.</code>放在行前来表示有序列表。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. George Washington</span><br><span class="line">2. John Adams</span><br><span class="line">3. Thomas Jefferson</span><br></pre></td></tr></table></figure><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>在嵌套列表项前面键入空格字符，直到列表标记字符（<code>-</code>或<code>*</code>）位于其上方项目中文本的第<strong>一</strong>个字符的正下方。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. First list item</span><br><span class="line">   - First nested list item</span><br><span class="line">     - Second nested list item</span><br></pre></td></tr></table></figure><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>要创建任务列表，请在列表标记字符（<code>-</code>或<code>*</code>）后加上<code>[</code>+空格+<code>]</code>。要将任务标记为完成，请用<code>x</code>代替空格（<code>[x]</code>）。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [ ] Is empty</span><br><span class="line">- [x] Selected</span><br></pre></td></tr></table></figure><p>如果任务列表项描述以括号开头，则需要使用命令<code>\</code>对其进行转义：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- [ ] \(Optional) Open a followup issue</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>可以使用管道<code>|</code>和连字符<code>-</code>创建表。连字符用于创建每个列的标题，而管道用于分隔每个列。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure><p>单元格的宽度可以不同，并且不需要在列内完美对齐。标题行的每列中必须至少有三个连字符。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| --- | ----- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure><p>可以通过在连字符的左侧，右侧或两侧包含冒号<code>:</code>来将文本对齐到列的左侧，右侧或中心。</p><p>要在您的单元格中包含管道<code>|</code>作为内容，请在管道前使用<code>\</code>进行转义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文参照：&lt;a href=&quot;https://help.github.com/en/categories/writing-on-github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://help.github.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTML5</title>
    <link href="http://yoursite.com/2019/03/09/H5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/09/H5学习笔记/</id>
    <published>2019-03-09T11:56:18.824Z</published>
    <updated>2019-03-09T11:56:58.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是H5？"><a href="#什么是H5？" class="headerlink" title="什么是H5？"></a>什么是H5？</h2><p>  HTML5是一种超文本标记语言，用于在万维网上构建和呈现网页内容。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Page Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;My First Heading&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;My first paragraph.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;!DOCTYPE html&gt;指该文件为HTML5，不区分大小写，</li><li><html>指这是一个HTML页面根元素，</html></li><li><head>元素包含该文档元信息，</head></li><li><title>元素指该文档标题，</title></li><li><body>元素指该文档可见页面，</body></li><li><h1>元素定义了一个大的标题</h1></li><li><p>元素定义了一个段落</p></li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>&lt;标记名&gt; 内容 &lt;/标记名&gt;</code><br>浏览器不显示HTML标记，但使用它们来确定如何显示文件，只有在body中的内容才会被显示在浏览器中。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li>文档开头必须使用文档类型开始：<strong>&lt;!DOCTYPE html&gt;</strong>。</li><li>必须以<strong><html></html></strong>开头和结尾。</li><li>可见部分为<strong><body></body></strong>和之间的。</li><li><h1>到<h6>标签定义HTML<strong>标题</strong>。</h6></h1></li><li>用<p>定义<strong>段落</strong>。</p></li><li>用<img>定义<strong>图片</strong>，src=源文件，alt=当无法显示图像时替代文本，width和height为图片宽度高度，例如：<img src="**.jpg" alt="****" width="104" height="142"></li><li><strong>style属性</strong>被用于指定一个元素的造型，如颜色，字体，大小等，例如：<p style="color:red">I am a paragraph</p>。</li><li>lang属性用于声明<strong>语言</strong>，可用在<html>，例如：<html lang="en-US">。</html></html></li><li>title属性被添加到<h>或<p>元件。当您将鼠标放在段落上时，title属性的值将显示为<strong>提示信息</strong>，例如：</p><p title="I'm a tooltip"><br>This is a paragraph.<br></p>。</h></li><li>html并不区分大小写，建议使用小写；引号尽量不要省略；当出现双引号时可以在外面套上单引号，出现单引号可以在外面套上双引号，例如：<p title="John "ShotGun" Nelson">和</p><p title="John 'ShotGun' Nelson">。</p></li><li><code>&lt;hr&gt;</code>元件用于在HTML页中分离内容，具体显示为一条水平线，没有结束标记。</li><li><code>&lt;br&gt;</code>元素定义换行，没有结束标记。</li><li><pre>元素定义预格式化文本，在该元素里面的文本被定义为一个等宽字体，并且它保留了等宽和换行。<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2>该HTML<head>元素与标题无关。该<head>元素是元数据的容器。HTML元数据是关于HTML文档的数据。元数据并不显示。该<head>元件放置在之间<html>标签和<body>。<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2>随着调整窗口大小将产生不同的结果，在显示页面时，浏览器将删除任何多余的空格和行。<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2></body></html></head></head></head></pre></li><li><strong>样式属性</strong>：<tagname style="property:value;"> tagname：标签名称；style：属性。</tagname></li><li><strong>背景颜色</strong>：background-color属性定义HTML元素的背景颜色，放在<html>中默认整个页面背景颜色，放在<body>中默认文本范围内背景颜色，放在<p>中默认该文本的背景颜色，若<html>没有设置而<body>中设置了，则<body>默认设置为整个页面背景颜色，例如<body style="background-color:powderblue;">，设置页面为灰蓝色。</body></body></body></html></p></body></html></li><li><strong>文本颜色</strong>：color属性定义HTML元素的文本颜色，注意与背景颜色的区别。例如：<h1 style="color:blue;">This is a heading</h1><p style="color:red;">This is a paragraph.</p></li><li><strong>字体种类</strong>：font-family属性定义字体种类，例如<h1 style="font-family:verdana;">This is a heading</h1><br><p style="font-family:courier;">This is a paragraph.</p>。</li><li>text-align定义文本<strong>水平对齐</strong>，例如：<p style="text-align:center;">Centered paragraph.</p>。</li><li>font-size属性定义文本<strong>字体大小</strong>，例如：<h1 style="font-size:300%;">This is a heading</h1>。<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2>格式元素被设计为显示特殊类型的文本：</li><li><strong><b></b></strong>：加粗字体，例如：<p><b>This text is bold.</b></p>。</li><li><strong><i></i></strong>：斜体，例如：<p><i>This text is italic.</i></p>。</li><li><strong><u></u></strong>：下划线，</li><li><strong><strong></strong>：重要文本(变粗)，例如：<p><strong>This text is strong.</strong></p>。</strong></li><li><strong><em></em></strong>：强调的文字(变倾斜)，例如：<p><em>This text is emphasized.</em></p></li><li><strong><mark></mark></strong>：标记的文本，mark后的文本背景变黄。</li><li><strong><small></small></strong>：小文本，例如：<h2>HTML <small>Small</small> Formatting</h2>。</li><li><strong><del></del></strong>：删除的文字，文本上会显示一条横线。</li><li><strong><ins></ins></strong>：插入文本，文本下显示下划线，例如：<p>My favorite <ins>color</ins> is red.</p>，color下加下划线。</li><li><code>&lt;sub&gt;</code>：下标文本，例如：<code>&lt;p&gt;This is &lt;sub&gt;subscripted&lt;/sub&gt;.&lt;/p&gt;</code>。 </li><li><code>&lt;sup&gt;</code>：上标文本，例如：<code>&lt;p&gt;This is &lt;sup&gt;superscripted&lt;/sup&gt; text.&lt;/p&gt;</code>。</li><li><strong><span></span></strong>：行内元素，没有任何特殊语义。可以通过使用类或者Id属性使用它来编组元素以达到某种样式意图<blockquote><p>浏览器中显示<strong>和<b>，<em>和<i>相同。但是 <b>和<i>定义粗体和斜体文字， <strong>和<em>意味着该文本是重要的。</em></strong></i></b></i></em></b></strong></p></blockquote></li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th style="text-align:center">原义字符</th><th style="text-align:center">等价字符引用</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">&amp;lt</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">&amp;gt</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">&amp;quot</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">&amp;apos</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">&amp;amp</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;In HTML, you define a paragraph using the &lt;p&gt; element.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;In HTML, you define a paragraph using the &amp;lt;p&amp;gt; element.&lt;/p&gt; </span><br><span class="line">//注意字符引用后的分号。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In HTML, you define a paragraph using the</span><br><span class="line">element.</span><br><span class="line">In HTML, you define a paragraph using the &lt;p&gt; element.</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li><strong>无序列表</strong> 中项目的顺序并不重要，就像购物列表。这些内容被包括在一个&lt; ul&gt;( 代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的。通常情况下，无序列表项的头部可以是几种形式，如一个点，一个圆形或方形。头部的风格并不是在页面的HTML描述定义, 但在其相关的CSS 可以用 list-style-type 属性。) 元素里。</li><li><strong>有序列表</strong>中项目的顺序很重要，就像一个食谱。这些内容被包括在一个<ol>元素里(表示多个有序列表项，通常渲染为有带编号的列表。) 元素里。</ol></li></ol><p>列表内的每个项目被包括在一个 <li> (用于表示列表里的条目。它必须被包含在一个父元素里：一个有顺序的列表(<ol>)，一个无顺序的列表(<ul>)，或者一个菜单 (<menu>)。)在菜单或者无顺序的列表里，列表条目通常用点排列显示。在有顺序的列表里，列表条目通常是在左边有按升序排列计数的显示，例如数字或者字母。”) (list item) 元素里。</menu></ul></ol></li></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是被浏览器忽略的，而且是对用户不可见的，用特殊的记号<!--和-->包括起来，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;p&gt;I am!&lt;/p&gt; --&gt;</span><br></pre></td></tr></table></figure></p><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>Ctrl + Shift + I 打开开发工具套件，检查当前加载的HTML、CSS和JavaScript，显示每个资源页面的请求以及载入所花费的时间。</p><h2 id="HTML中的CSS和JavaScript"><a href="#HTML中的CSS和JavaScript" class="headerlink" title="HTML中的CSS和JavaScript"></a>HTML中的CSS和JavaScript</h2><ul><li><link>，这个元素最常于链接样式表， 元素经常位于文档的头部，rel=”stylesheet”，表明这是样式表，而 href包含了样式表文件的路径：<link rel="stylesheet" href="my-css-file.css">。</li><li><script>元素用于嵌入或引用可执行脚本。没必要非要放在文档头部；实际上，把它放在文档的尾部（在 </body>标签之前`）是一个更好的选择 ，这样可以确保在加载脚本之前浏览器已经解析了HTML内容。</li></ul><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>用<a>定义，例如：<a href="url" title:"链接文字描述"> 触发链接的元素(可以使一句话或者一个块级元素) </a>。</p><p>超链接可以链接到html文档的特定部分，而不仅仅是文件的顶部。</p><ul><li>要做到这一点你必须首先给要链接的元素分配一个id属性。<blockquote><h2 id="Mailing_address">Mailing address</h2></blockquote></li><li>然后链接到那个特定的id，您可以在URL的结尾包含它，前面是一个井号(#)。<blockquote><p>Want to write us a letter? Use our <a href="contacts.html#Mailing_address">mailing address</a>.</p></blockquote></li><li>甚至可以用链接到同一份文件的另一部分。<blockquote><p>The <a href="#Mailing_address">company mailing address</a> can be found at the bottom of this page.</p></p></blockquote></li></ul><p>当链接到要下载的资源时, 可以使用下载属性来提供一个默认的保存文件名。</p><blockquote><p><a href="https://download.mozilla.org/?product=firefox-latest-ssl&os=win64&lang=en-US"   download="firefox-latest-64bit-installer.exe"><br>  Download Latest Firefox for Windows (64-bit) (English, US)</a></p></blockquote><h2 id="描述列表"><a href="#描述列表" class="headerlink" title="描述列表"></a>描述列表</h2><p>描述列表使用与其他列表类型不同的闭合标签<dl>，它是一个包含术语定义<dt>以及描述<dd>的列表，通常用于展示词汇表或者元数据 (键-值对列表)。 此外，每一项都用 <dt>元素 （或 HTML 术语定义元素）闭合。该元素仅能作为 <dl> 的子元素出现。通常在该元素后面会跟着 <dd> 元素， 然而，多个连续出现的 <dt> 元素都将由出现在它们后面的第一个 <dd> 元素定义。一个<dt>可以同时有多个描述<dd>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;soliloquy&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;In drama, where a character speaks to themselves, representing their inner thoughts or feelings and in the process relaying them to the audience (but not to other characters.)&lt;/dd&gt;</span><br><span class="line">  &lt;dt&gt;monologue&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;In drama, where a character speaks their thoughts out loud to share them with the audience and any other characters present.&lt;/dd&gt;</span><br><span class="line">  &lt;dt&gt;aside&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;In drama, where a character shares a comment only with the audience for humorous or dramatic effect. This is usually a feeling, thought or piece of additional background information.&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h3><p>如果一个块级内容（一个段落、多个段落、一个列表等）从其他地方被引用，你应该把它用<blockquote>元素包括起来，代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进。若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 属性上。若要以文本方式包括，则要用<cite>元素包括。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote cite=&quot;https://example.com&quot;&gt;</span><br><span class="line">  &lt;p&gt;The &lt;strong&gt;HTML &lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt; Element&lt;/strong&gt; (or &lt;em&gt;HTML Block</span><br><span class="line">  Quotation Element&lt;/em&gt;) indicates that the enclosed text is an extended quotation.&lt;/p&gt;</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure></p><h3 id="行内引用"><a href="#行内引用" class="headerlink" title="行内引用"></a>行内引用</h3><p>使用<q>元素进行行内引用，<q>元素旨在用于不需要分段的短引用。会自动加上引号。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;The quote element — &lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt; — is &lt;q cite=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt;intended</span><br><span class="line">for short quotations that don&apos;t require paragraph breaks.&lt;/q&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><h2 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h2><p><abbr>它常被用来包裹一个缩略语或缩写，并且提供缩写的解释(包含在title属性中)。当鼠标移动到上时会出现提示。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;abbr title=&quot;Hypertext Markup Language&quot;&gt;HTML&lt;/abbr&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><h2 id="标记联系方式"><a href="#标记联系方式" class="headerlink" title="标记联系方式"></a>标记联系方式</h2><p>用<address>标记联系方式。</p><h2 id="标记代码块"><a href="#标记代码块" class="headerlink" title="标记代码块"></a>标记代码块</h2><ul><li><code>：用于标记计算机通用代码。</li><li><pre>：保留的空格（通常是代码块）——如果您在文本中使用缩进或多余的空白，浏览器将忽略它，您将不会在呈现的页面上看到它。但是，如果您将文本包含在<pre></pre>标签中，那么空白将会以与你在文本编辑器中看到的相同的方式渲染出来。</li><li><var>：用于标记具体变量名。</li><li><kbd>：用于标记输入电脑的键盘（或其他类型）输入。</li><li><samp>：用于标记计算机程序的输出。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;var para = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">para.onclick = function() &#123;</span><br><span class="line">  alert(&apos;Owww, stop poking me!&apos;);</span><br><span class="line">&#125;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;You shouldn&apos;t use presentational elements like &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;In the above JavaScript example, &lt;var&gt;para&lt;/var&gt; represents a paragraph element.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;Select all the text with &lt;kbd&gt;Ctrl&lt;/kbd&gt;/&lt;kbd&gt;Cmd&lt;/kbd&gt; + &lt;kbd&gt;A&lt;/kbd&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;$ &lt;kbd&gt;ping mozilla.org&lt;/kbd&gt;</span><br><span class="line">&lt;samp&gt;PING mozilla.org (63.245.215.20): 56 data bytes</span><br><span class="line">64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms&lt;/samp&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var para = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">para.onclick = function() &#123;</span><br><span class="line">  alert(&apos;Owww, stop poking me!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">You shouldn&apos;t use presentational elements like &lt;font&gt; and &lt;center&gt;.</span><br><span class="line"></span><br><span class="line">In the above JavaScript example, para represents a paragraph element.</span><br><span class="line"></span><br><span class="line">Select all the text with Ctrl/Cmd + A.</span><br><span class="line"></span><br><span class="line">$ ping mozilla.org</span><br><span class="line">PING mozilla.org (63.245.215.20): 56 data bytes</span><br><span class="line">64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms</span><br></pre></td></tr></table></figure><h3 id="标记时间"><a href="#标记时间" class="headerlink" title="标记时间"></a>标记时间</h3><p>用<time>标记可以被机器识别的时间，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;time datetime=&quot;2016-01-20&quot;&gt;20 January 2016&lt;/time&gt;</span><br></pre></td></tr></table></figure></p><p>datetime可以被识别。</p><h2 id="标记联系人信息"><a href="#标记联系人信息" class="headerlink" title="标记联系人信息"></a>标记联系人信息</h2><p>HTML有一个用于标记联系人详细信息的元素 -<address>，简单地包含了您的联系方式，<br>但要记住的一点是，该<address>元素用于标记编写HTML文档的人员的联系人详细信息，而不是<em>任何</em>地址。</p><h2 id="用于结构化网站的HTML"><a href="#用于结构化网站的HTML" class="headerlink" title="用于结构化网站的HTML"></a>用于结构化网站的HTML</h2><ul><li><strong>标题</strong>:<header>元素表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</li><li><strong>导航栏</strong>: <nav>描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。</li><li><strong>主要内容</strong>: <main>元素呈现了文档<body>或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。这部分内容在文档中应当是独一无二的，不包含任何在一系列文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。具有代表性的内容段落主题可以使用<strong><article></strong>，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。<strong><section></strong>元素表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (<h1>-<h6> element) 作为子节点 来 辨识每一个<section>。<div>元素是一个通用型的流内容容器，它在语义上不代表任何特定类型的内容，它可以被用来对其它元素进行分组，一般用于样式化相关的需求（使用 class 或 id 特性) 或者对具有相同特性的一组元素进行分组 (比如 lang)，它应该在没有任何其它语义元素可用时才使用 (比如 <article> 或 <nav>) </li><li><strong>侧栏</strong>:<aside>元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。经常嵌套在<main>中。</li><li><strong>页脚</strong>: <footer> 元素表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</li></ul><h2 id="视频和音频"><a href="#视频和音频" class="headerlink" title="视频和音频"></a>视频和音频</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=&quot;video1.webm&quot; controls&gt;</span><br><span class="line">  &lt;p&gt;If your browser doesn&apos;t support HTML5 video. Here is a &lt;a href=&quot;video1.webm&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt; </span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure></p><p>在页面中加入视频。</p><ul><li>src：视频URL。</li><li>controls：控制视频或音频播放。</li><li><video>内的<p>：当浏览器不支持video的格式时展现出来。</li></ul><h4 id="多格式支持"><a href="#多格式支持" class="headerlink" title="多格式支持"></a>多格式支持</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls&gt;</span><br><span class="line">  &lt;source src=&quot;video1.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;video1.webm&quot; type=&quot;video/webm&quot;&gt;</span><br><span class="line">  &lt;p&gt;If your browser doesn&apos;t support HTML5 video. Here is a &lt;a href=&quot;video1.mp4&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><p>将 src 属性从 <video> 标签中移除，转而将它放在几个单独的标签<source>当中。在这个例子当中，浏览器将会检查 <source> 标签，并且播放第一个与其自身 codec(解码器) 相匹配的媒体。你的视频应当包括 WebM 和 MP4 两种格式，这两种在目前已经足够支持大多数平台和浏览器。</p><p>每个 <source>标签页含有一个 type 属性，这个属性是可选的，但是建议你添加上这个属性 — 它包含了视频文件的 MIME types(媒体类型/内容类型)，同时浏览器也会通过检查这个属性来迅速的跳过那些不支持的格式。如果你没有添加 type 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这样会消耗掉大量的时间和资源。</p><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li>width和height：控制视频的尺寸，但是video总会保持它原始的长宽比 — 也叫做纵横比。如果你设置的尺寸没有保持视频原始长宽比，那么视频边框将会拉伸，而未被视频内容填充的部分，将会显示默认的背景颜色。</li><li>autoplay：即使页面的其他部分还没有加载完全，也会使音频和视频立即播放。</li><li>loop：使音频或者视频循环播放。</li><li>muted：会使媒体播放时，默认关闭声音。</li><li>poster：指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或广告。</li><li>preload：被用来缓冲较大的文件，有3个值可选：<pre><code>1. none：不缓冲。2. auto：页面加载后缓存媒体文件。3. metadata：仅缓冲文件的元数据。</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls width=&quot;400&quot; height=&quot;400&quot;</span><br><span class="line">       autoplay loop muted</span><br><span class="line">       poster=&quot;poster.png&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;video1.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;video1.webm&quot; type=&quot;video/webm&quot;&gt;</span><br><span class="line">  &lt;p&gt;If your browser doesn&apos;t support HTML5 video. Here is a &lt;a href=&quot;video1.mp4&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio controls&gt;</span><br><span class="line">  &lt;source src=&quot;audio1.mp3&quot; type=&quot;audio/mp3&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;audio1.ogg&quot; type=&quot;audio/ogg&quot;&gt;</span><br><span class="line">  &lt;p&gt;If your browser doesn&apos;t support HTML5 audio. Here is a &lt;a href=&quot;audio1.mp3&quot;&gt;link to the audio&lt;/a&gt; instead.&lt;/p&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure></p><p>加入音频。</p><p>audio不支持width/height和poster。其他同video。</p><h4 id="如何显示音轨文本"><a href="#如何显示音轨文本" class="headerlink" title="如何显示音轨文本"></a>如何显示音轨文本</h4><p>通过添加音频副本的方式添加字幕。</p><p>WebVTT 是一个格式，用来编写文本文件，这个文本文件包含了众多的字符串，这些字符串会带有一些元数据，它们可以用来描述这个字符串将会在视频中显示的时间，甚至可以用来描述这些字符串的样式以及定位信息。这些字符串叫做 cues ，你可以根据不同的需求来显示不同的样式，最常见的如下：</p><ul><li>subtitle：通过添加翻译字幕，来帮助那些听不懂人们理解音频当中的内容。</li><li>captions：同步翻译对白，或是描述一些有重要信息的声音，来帮助那些不能听音频的人们理解音频中的内容。</li><li>timed descriptions：将文字转换为音频，用于服务那些有视觉障碍的人。</li></ul><ol><li>以 .vtt 后缀名保存文件。</li><li>用<track>标签链接 .vtt 文件，<track>标签需放在 <audio> 或 <video> 标签当中，同时需要放在所有 <source> 标签<strong>之后</strong>。使用kind属性来指明是哪一种类型，如 subtitles 、 captions 、 descriptions。然后，使用 srclang来告诉浏览器你是用什么语言来编写的 subtitles。</li></ol><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls&gt;</span><br><span class="line">    &lt;source src=&quot;example.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;example.webm&quot; type=&quot;video/webm&quot;&gt;</span><br><span class="line">    &lt;track kind=&quot;subtitles&quot; src=&quot;subtitles_en.vtt&quot; srclang=&quot;en&quot;&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure></p><h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><h3 id=""><a href="#" class="headerlink" title=""></a><iframe></h3><p><iframe>元素允许您将其他Web文档嵌入到当前文档中。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;https://example.com&quot;</span><br><span class="line">        width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot;</span><br><span class="line">        allowfullscreen sandbox&gt;</span><br><span class="line">  &lt;p&gt; &lt;a href=&quot;https://example.com&quot;&gt;</span><br><span class="line">    Fallback link for browsers that don&apos;t support iframes</span><br><span class="line">  &lt;/a&gt; &lt;/p&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><ul><li>src：要嵌入文档的URL。</li><li>width和height：指定想要的iframe的宽度和高度。</li><li>allowfullscreen：可以通过全屏API设置<iframe>为全屏模式.</li><li>frameborder：如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，默认。0删除边框。</li><li>sandbox 在沙盒中运行，可以提高安全性设置。</li></ul><h4 id="和"><a href="#和" class="headerlink" title="和"></a><embed>和<object></h4><p>用于嵌入视频，SVG，图像甚至Flash</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG是用于描述矢量图像的XML语言。</p><ul><li>位图：使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.)</li><li>矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 SVG格式可以让我们创造用于 Web 的精彩的矢量图形。</li></ul><ol><li>可以通过<img>嵌入。不过将无法使用JavaScript操作图像。如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。</li><li>SVG内联，在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中，确保您的SVG代码在<svg></svg>标签中。内联SVG是唯一可以让您在SVG图像上使用CSS交互.</li></ol><h2 id="自适应图片"><a href="#自适应图片" class="headerlink" title="自适应图片"></a>自适应图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img srcset=&quot;elva-fairy-320w.jpg 320w,</span><br><span class="line">             elva-fairy-480w.jpg 480w,</span><br><span class="line">             elva-fairy-800w.jpg 800w&quot;</span><br><span class="line">     sizes=&quot;(max-width: 320px) 280px,</span><br><span class="line">            (max-width: 480px) 440px,</span><br><span class="line">            800px&quot;</span><br><span class="line">     src=&quot;elva-fairy-800w.jpg&quot; alt=&quot;Elva dressed as a fairy&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>srcset：定义了我们允许浏览器选择的图像集，以及每个图像的大小；文件名+空格+图像的固有宽度（以像素为单位）。</li><li>sizes：定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。；媒体条件+空格+槽的宽度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">  &lt;source type=&quot;image/svg+xml&quot; srcset=&quot;pyramid.svg&quot;&gt;</span><br><span class="line">  &lt;source type=&quot;image/webp&quot; srcset=&quot;pyramid.webp&quot;&gt; </span><br><span class="line">  &lt;img src=&quot;pyramid.png&quot; alt=&quot;regular pyramid built from four equilateral triangles&quot;&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure><p>可以使用picture来进行图片格式的选择</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Company&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Address&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Apple, Inc.&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;1 Infinite Loop Cupertino, CA 95014&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>表格用table元素包括。</p><ul><li>由<strong>th</strong>元素创建的表头单元格，包含表头信息。</li><li>由<strong>td</strong>元素创建的标准单元格，包含数据。<br><strong>th</strong>元素内部的文本通常会呈现为居中的粗体文本，而<strong>td</strong>元素内的文本通常是左对齐的普通文本。</li></ul></script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是H5？&quot;&gt;&lt;a href=&quot;#什么是H5？&quot; class=&quot;headerlink&quot; title=&quot;什么是H5？&quot;&gt;&lt;/a&gt;什么是H5？&lt;/h2&gt;&lt;p&gt;  HTML5是一种超文本标记语言，用于在万维网上构建和呈现网页内容。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA博客文章收藏</title>
    <link href="http://yoursite.com/2019/03/09/JAVA%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F/"/>
    <id>http://yoursite.com/2019/03/09/JAVA博客收藏/</id>
    <published>2019-03-09T11:54:50.936Z</published>
    <updated>2019-03-30T12:30:17.162Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.jianshu.com/p/4277bbcab647" target="_blank" rel="noopener">动态绑定与静态绑定</a></li><li><a href="https://blog.csdn.net/snow_7/article/details/51579278" target="_blank" rel="noopener">隐藏和覆盖</a></li><li><a href="https://blog.csdn.net/youngstar70/article/details/60953578" target="_blank" rel="noopener">为什么子类一定要访问父类中的构造函数</a></li><li><a href="https://blog.csdn.net/u011299745/article/details/52887825" target="_blank" rel="noopener">关于static和static+final的区别，以及编译阶段的常量传播优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/4277bbcab647&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态绑定与静态绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XV6环境配置</title>
    <link href="http://yoursite.com/2019/03/09/XV6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/09/XV6环境配置/</id>
    <published>2019-03-09T11:53:05.077Z</published>
    <updated>2019-03-09T11:53:40.773Z</updated>
    
    <content type="html"><![CDATA[<p>MIT 6.828 需要使用两种工具：x86模拟器：qemu 和 编译器工具链。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Ubuntu18.04</p><h2 id="测试编译器工具链"><a href="#测试编译器工具链" class="headerlink" title="测试编译器工具链"></a>测试编译器工具链</h2><p>###第一步：</p><blockquote><p>$ objdump -i</p></blockquote><p>第二行应该为 elf32-i386。<br>我的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">BFD 头文件版本 (GNU Binutils for Ubuntu) 2.30</span><br><span class="line">elf64-x86-64</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">elf32-i386</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">elf32-iamcu</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  iamcu</span><br><span class="line">elf32-x86-64</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">a.out-i386-linux</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">pei-i386</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">pei-x86-64</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">elf64-l1om</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  l1om</span><br><span class="line">elf64-k1om</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  k1om</span><br><span class="line">elf64-little</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">elf64-big</span><br><span class="line"> (header 大端序, data 大端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">elf32-little</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">elf32-big</span><br><span class="line"> (header 大端序, data 大端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">pe-x86-64</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">pe-bigobj-x86-64</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">pe-i386</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">  i386</span><br><span class="line">plugin</span><br><span class="line"> (header 小端序, data 小端序)</span><br><span class="line">srec</span><br><span class="line"> (header 未知的端序, data 未知的端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">symbolsrec</span><br><span class="line"> (header 未知的端序, data 未知的端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">verilog</span><br><span class="line"> (header 未知的端序, data 未知的端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">tekhex</span><br><span class="line"> (header 未知的端序, data 未知的端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">binary</span><br><span class="line"> (header 未知的端序, data 未知的端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">ihex</span><br><span class="line"> (header 未知的端序, data 未知的端序)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line"></span><br><span class="line">         elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 a.out-i386-linux </span><br><span class="line">    i386 elf64-x86-64 elf32-i386 ----------- elf32-x86-64 a.out-i386-linux</span><br><span class="line">    l1om ------------ ---------- ----------- ------------ ----------------</span><br><span class="line">    k1om ------------ ---------- ----------- ------------ ----------------</span><br><span class="line">   iamcu ------------ ---------- elf32-iamcu ------------ ----------------</span><br><span class="line">  plugin ------------ ---------- ----------- ------------ ----------------</span><br><span class="line"></span><br><span class="line">         pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big </span><br><span class="line">    i386 pei-i386 pei-x86-64 ---------- ---------- elf64-little elf64-big</span><br><span class="line">    l1om -------- ---------- elf64-l1om ---------- elf64-little elf64-big</span><br><span class="line">    k1om -------- ---------- ---------- elf64-k1om elf64-little elf64-big</span><br><span class="line">   iamcu -------- ---------- ---------- ---------- elf64-little elf64-big</span><br><span class="line">  plugin -------- ---------- ---------- ---------- elf64-little elf64-big</span><br><span class="line"></span><br><span class="line">         elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 plugin srec </span><br><span class="line">    i386 elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 ------ srec</span><br><span class="line">    l1om elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line">    k1om elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line">   iamcu elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line">  plugin elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line"></span><br><span class="line">         symbolsrec verilog tekhex binary ihex </span><br><span class="line">    i386 symbolsrec verilog tekhex binary ihex</span><br><span class="line">    l1om symbolsrec verilog tekhex binary ihex</span><br><span class="line">    k1om symbolsrec verilog tekhex binary ihex</span><br><span class="line">   iamcu symbolsrec verilog tekhex binary ihex</span><br><span class="line">  plugin symbolsrec verilog tekhex binary ihex</span><br></pre></td></tr></table></figure></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote><p>$ gcc -m32 -print-libgcc-file-name</p></blockquote><p>应该输出：</p><blockquote><p>/ usr / lib / gcc / i486-linux-gnu / version /libgcc.a</p></blockquote><p>或 </p><blockquote><p>/ usr / lib / gcc / x86_64-linux-gnu / version /32/libgcc.a</p></blockquote><p>我的：</p><blockquote><p>/usr/lib/gcc/x86_64-linux-gnu/<strong>6</strong>/32/libgcc.a</p></blockquote><p>关于GCC版本的问题，默认安装的是7，但是后面会出现问题，稍后再说。</p><h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><p>安装的qemu是修订版本，不是发行版。<br>克隆6.828 QEMU git存储库。</p><blockquote><p>git clone <a href="https://github.com/mit-pdos/6.828-qemu.git" target="_blank" rel="noopener">https://github.com/mit-pdos/6.828-qemu.git</a> qemu</p></blockquote><p>速度有点慢，不过还行，洗把脸的功夫。</p><p>可能需要安装下面这些包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libglib2.0-dev</span><br><span class="line">$ sudo apt-get install libz-dev</span><br><span class="line">$ sudo apt-get install libpixman-1-dev</span><br><span class="line">$ sudo apt-get install libsdl1.2-dev</span><br></pre></td></tr></table></figure></p><p>我最后一个包缺少依赖安装不成功，不要管，继续。<br>克隆完成后，切换到qemu主目录</p><blockquote><p>$ cd qemu</p></blockquote><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote><p>$ sudo ./configure –prefix=/usr/local –target-list=”i386-softmmu x86_64-softmmu”</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>$sudo make &amp;&amp; sudo make install</p></blockquote><h4 id="下面是重点-发生的error"><a href="#下面是重点-发生的error" class="headerlink" title="下面是重点 发生的error"></a>下面是重点 发生的error</h4><h5 id="1-”major”和”minor”"><a href="#1-”major”和”minor”" class="headerlink" title="1.”major”和”minor”"></a>1.”major”和”minor”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">quotactl.c: In function ‘find_home_device’:</span><br><span class="line">quotactl.c:31:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;. For historical compatibility, it is</span><br><span class="line"> currently defined by &lt;sys/types.h&gt; as well, but we plan to</span><br><span class="line"> remove this soon. To use &quot;major&quot;, include &lt;sys/sysmacros.h&gt;</span><br><span class="line"> directly. If you did not intend to use a system-defined macro</span><br><span class="line"> &quot;major&quot;, you should undefine it after including &lt;sys/types.h&gt;.</span><br></pre></td></tr></table></figure><p>这是因为major被定义在&lt;sys/sysmacros.h&gt;，由于历史兼容性&lt;sys/types.h&gt;也有定义，但是要被移除了，所以你应该在头文件包括&lt;sys/sysmacros.h&gt;。<br>打开commands-posix.c</p><blockquote><p>$ vim commands-posix.c</p></blockquote><p>添加 <strong>#include &lt;sys/sysmacros.h&gt;</strong><br>重新执行</p><h5 id="2-’-s’"><a href="#2-’-s’" class="headerlink" title="2.’%s’"></a>2.’%s’</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blkdebug.c:693:31: error: &apos;%s&apos; directive output may be truncated writing </span><br><span class="line">up to 4095 bytes into a region of size 4086 [-Werror=format-truncation=]</span><br></pre></td></tr></table></figure><p>这个好像时因为GCC版本过高(7)，对<a href="https://blog.csdn.net/helloworld19970916/article/details/81603056" target="_blank" rel="noopener">printf输出更加严格</a>，直接把GCC改为6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-alternatives --remove-all gcc </span><br><span class="line">$ sudo update-alternatives --remove-all g++</span><br><span class="line">$ sudo apt-get install gcc-6</span><br><span class="line">$ sudo apt-get install gcc-6</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc6 100</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 100</span><br><span class="line">$ sudo update-alternatives --config gcc</span><br><span class="line">$ sudo update-alternatives --config gcc</span><br></pre></td></tr></table></figure></p><p>最后gcc -v查看版本<br>再次make &amp;&amp; make install</p><h2 id="克隆6-828源码"><a href="#克隆6-828源码" class="headerlink" title="克隆6.828源码"></a>克隆6.828源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/6.828</span><br><span class="line">cd ~/6.828</span><br><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure><p>切换到lab目录下</p><blockquote><p>make</p></blockquote><p>生成一个kernel.img</p><blockquote><p>make qemu</p></blockquote><h5 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h5><p>可能会有”undefined reference to `__udivdi3’错误，你需要取下载对应版本的multilib。</p><blockquote><p>$sudo apt-get install gcc-6-multilib g++-6-multilib</p></blockquote><p>重新make qemu<br>出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">VNC server running on `127.0.0.1:5900&apos;</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &apos;help&apos; for a list of commands.</span><br><span class="line">K&gt;</span><br></pre></td></tr></table></figure></p><p>即安装成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MIT 6.828 需要使用两种工具：x86模拟器：qemu 和 编译器工具链。&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;Ubuntu18.04&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="http://yoursite.com/2018/12/23/C/"/>
    <id>http://yoursite.com/2018/12/23/C/</id>
    <published>2018-12-23T07:43:57.426Z</published>
    <updated>2018-12-23T07:48:09.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scanf-��-gets-������"><a href="#scanf-��-gets-������" class="headerlink" title="scanf �� gets ������"></a>scanf �� gets ������</h2><p>scanf��</p><ul><li>���ܽ��ܿո��Ʊ��Tab���س��ȣ�</li></ul><ul><li>�������س����ո��tab�����Զ����ַ���������� ‘\0’�����ǻس����ո��tab���Ի�<strong>��������Ļ�����</strong>�С�</li></ul><p>gets:</p><ul><li>�ܹ����ܿո��Ʊ��Tab�ͻس��ȣ�</li></ul><ul><li>�ɽ��ܻس���֮ǰ����������ַ������� ‘\0’ ��� ‘\n’ ���س�<strong>�����������뻺����</strong>�С�</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scanf-��-gets-������&quot;&gt;&lt;a href=&quot;#scanf-��-gets-������&quot; class=&quot;headerlink&quot; title=&quot;scanf �� gets ������&quot;&gt;&lt;/a&gt;scanf �� gets ������&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="http://yoursite.com/2018/09/14/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/14/状态管理/</id>
    <published>2018-09-14T13:49:08.859Z</published>
    <updated>2018-09-16T02:44:12.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>用Data Stream API编写的程序通常以各种形式保存状态：</p><ul><li>Windows会在触发元素或聚合之前收集元素或聚合</li><li>转换函数可以使用键/值状态接口来存储值</li><li>转换函数可以实现<code>CheckpointedFunction</code>接口以使其局部变量具有容错能力。</li></ul><p>状态如何在内部表示，以及如何以及如何在检查点上持久化，取决于所选的状态后端。</p><h2 id="状态后端"><a href="#状态后端" class="headerlink" title="状态后端"></a>状态后端</h2><p>Flink捆绑了这些状态后端：</p><ul><li>MemoryStateBackend (默认)</li><li>FsStateBackend</li><li>RocksDBStateBackend</li></ul><h4 id="MemoryStateBackend"><a href="#MemoryStateBackend" class="headerlink" title="MemoryStateBackend"></a>MemoryStateBackend</h4><p>默认以java堆的对象形式保存数据，Key/value状态和窗口运算中的数据，用hash表来存储值、触发器等信息。基于checkpoints接口的方式，状态后端将对状态进行快照，并作为检查点的一部分，发送通知给JobManager (master)，这些数据同样存储在java堆中。</p><h4 id="FsStateBackend"><a href="#FsStateBackend" class="headerlink" title="FsStateBackend"></a>FsStateBackend</h4><p>可以通过一个文件系统的URL来配置(type, address, path), 例如 :”hdfs://namenode:40010/flink/checkpoints”或者 “file:///data/flink/checkpoints”。FsStateBackend将正在运行的数据保存TaskManager内存中。<br> 在做检查点时, 它将包含状态的快照信息写入配置好的文件系统目录中，. 最小的元数据信息被存储到JobManager的内存中。</p><h4 id="RocksDBStateBackend"><a href="#RocksDBStateBackend" class="headerlink" title="RocksDBStateBackend"></a>RocksDBStateBackend</h4><p>可以通过一个文件系统的URL来配置(type, address, path), 例如 :”hdfs://namenode:40010/flink/checkpoints”或者 “file:///data/flink/checkpoints”。FsStateBackend将正在运行的数据保存TaskManager内存中，存储到RocksDB(<a href="http://rocksdb.org/" target="_blank" rel="noopener">http://rocksdb.org/</a>) 数据库中. 在做检查点时, 所有RocksDB数据库的数据将通过检查点保存到文件系统目录中，. 最小的元数据信息被存储到JobManager的内存中。</p><h2 id="Keyed-State-and-Operator-State："><a href="#Keyed-State-and-Operator-State：" class="headerlink" title="Keyed State and Operator State："></a>Keyed State and Operator State：</h2><h4 id="键控state："><a href="#键控state：" class="headerlink" title="键控state："></a>键控state：</h4><p>基于KeyedStream上的状态，与key绑定。<br>可以将Keyed State看成已经被分区的Operator State，每个key都有一个状态分区。每一个keyed-state都绑定了唯一的一个&lt;parallel-operator-instance, key&gt;。因为每个key都属于一个 keyed operator的并行实例，所以我们可以把它看作是&lt;operator, key&gt;。</p><h4 id="算子state："><a href="#算子state：" class="headerlink" title="算子state："></a>算子state：</h4><p>Operator State跟一个特定operator的一个并发实例绑定，整个operator只对应一个state。而一个operator上可能会有多个key，对应多个keyed state。<br>Kafka Connector就是在Flink中使用Operator State的一个很好的例子，每个Kafka consumer的并行实例保存着一个topic分区和偏移量的映射作为它的Operator state。</p><h2 id="Raw-and-Managed-State"><a href="#Raw-and-Managed-State" class="headerlink" title="Raw and Managed State"></a>Raw and Managed State</h2><p>键控state和算子state有两种存在形式：原始状态和托管状态。</p><ul><li>raw state即原始状态，由用户自行管理具体的数据结构的状态，使用byte[]来读写状态内容，写到检查点，对其内部数据结构一无所知。</li><li>managed state托管状态，是由Flink框架管理的状态，由Flink运行时控制的数据结构表示，例如内部哈希表或RocksDB，Flink的runtime对状态进行编码并将它们写入检查点。<br>DataStream上推荐使用托管状态，当实现一个用户自定义的operator时，会使用到原始状态。</li></ul><h2 id="Using-Managed-Keyed-State"><a href="#Using-Managed-Keyed-State" class="headerlink" title="Using Managed Keyed State"></a>Using Managed Keyed State</h2><p>managed keyed state接口提供了对不同类型状态 (当前输入元素的key的) 的访问，这种类型的状态只能运用在KeyedStream (通过stream.keyBy(…)生成)。<br>几种不同类型的状态：</p><ul><li>ValueState<t>：保留了一个可以更新和检索的值，比如通过key查出对应的值，使用update(T)来更新值，T value()设置该值。</t></li><li>ListState<t>：可以追加元素并检索Iterable (迭代)所有当前存储的元素，使用add(T)或addAll(List<t>)添加元素，可以使用Iterable检索Iterable<t> get()。您也可以使用update(List<t>)覆盖现有列表。</t></t></t></t></li><li>ReducingState<t>：这保留一个值，表示添加到状态的所有值的聚合，使用add(T)添加的元素简化为使用ReduceFunction的一个集合。</t></li><li>AggregatingState&lt;IN, OUT&gt;：这保留了一个单独的值，它代表了添加到该状态的所有值的聚合。与ReducingState相反，聚合类型可能不同于添加到该状态的元素类型，add(IN)添加的元素是使用指定的AggregateFunction聚合的。</li><li>FoldingState&lt;T, ACC&gt;: 这保留了一个单独的值，它代表了添加到该状态的所有值的聚合。与ReducingState相反，聚合类型可能不同于添加到该状态的元素类型，add(IN)添加的元素是使用指定的FoldFunction聚合的。</li><li>MapState&lt;UK, UV&gt;: 这将保留映射列表。您可以将key-value对放入状态，并检索Iterable所有当前存储的映射。使用put(UK, UV)或 putAll(Map&lt;UK, UV&gt;)添加映射。可以使用检索与用户key关联的值get(UK)。对于映射，可以使用entries()，keys()和values()分别检索映射，键和值的迭代视图。<br>可以用clean() 清除对应key的值。</li></ul><p>重要的是要记住，这些状态对象仅用于状态的接口。状态不一定存储在内部，但可能驻留在磁盘或其他位置。要记住的第二件事是，从状态获得的值取决于input元素的key。因此，如果所涉及的key不同，则在一次调用用户函数时获得的值可能与另一次调用中的值不同。</p><p>必须使用StateDescriptor获得状态句柄，它保存了状态的名称（您可以创建多个状态，并且它们必须具有唯一的名称以便您可以引用它们），状态所持有的值的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class CountWindowAverage extends RichFlatMapFunction&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  ValueState 句柄. The first field is the count, the second field a running sum.</span><br><span class="line">     */</span><br><span class="line">    private transient ValueState&lt;Tuple2&lt;Long, Long&gt;&gt; sum;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void flatMap(Tuple2&lt;Long, Long&gt; input, Collector&lt;Tuple2&lt;Long, Long&gt;&gt; out) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 访问 state value</span><br><span class="line">        Tuple2&lt;Long, Long&gt; currentSum = sum.value();</span><br><span class="line"></span><br><span class="line">        // 更新 count</span><br><span class="line">        currentSum.f0 += 1;</span><br><span class="line"></span><br><span class="line">        // 添加input值的第二个字段</span><br><span class="line">        currentSum.f1 += input.f1;</span><br><span class="line"></span><br><span class="line">        //更新 state</span><br><span class="line">        sum.update(currentSum);</span><br><span class="line"></span><br><span class="line">        //如果 count 达到 2, 输出平均值并清除 state</span><br><span class="line">        if (currentSum.f0 &gt;= 2) &#123;</span><br><span class="line">            out.collect(new Tuple2&lt;&gt;(input.f0, currentSum.f1 / currentSum.f0));</span><br><span class="line">            sum.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void open(Configuration config) &#123;</span><br><span class="line">        ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt; descriptor =</span><br><span class="line">                new ValueStateDescriptor&lt;&gt;(</span><br><span class="line">                        &quot;average&quot;, //state 名称</span><br><span class="line">                        TypeInformation.of(new TypeHint&lt;Tuple2&lt;Long, Long&gt;&gt;() &#123;&#125;), // 类型信息</span><br><span class="line">                        Tuple2.of(0L, 0L)); //如果没设置， state 默认值</span><br><span class="line">        sum = getRuntimeContext().getState(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以像在 streaming 程序中使用 (假如我们有 StreamExecutionEnvironment env)</span><br><span class="line">env.fromElements(Tuple2.of(1L, 3L), Tuple2.of(1L, 5L), Tuple2.of(1L, 7L), Tuple2.of(1L, 4L), Tuple2.of(1L, 2L))</span><br><span class="line">        .keyBy(0)</span><br><span class="line">        .flatMap(new CountWindowAverage())</span><br><span class="line">        .print();</span><br><span class="line"></span><br><span class="line">// 输出为 (1,4) and (1,5)</span><br></pre></td></tr></table></figure></p><p>该函数将计数和运行总和存储在ValueState中。一旦计数达到2，它将发出平均值并清除状态，以便我们重新开始0。</p><h2 id="Using-Managed-Operator-State"><a href="#Using-Managed-Operator-State" class="headerlink" title="Using Managed Operator State"></a>Using Managed Operator State</h2><p>有状态函数可以实现更通用的CheckpointedFunction接口去使用Managed Operator State。</p><h4 id="CheckpointedFunction"><a href="#CheckpointedFunction" class="headerlink" title="CheckpointedFunction"></a>CheckpointedFunction</h4><p>CheckpointedFunction接口通过不同的再分配方案提供对非键控状态的访问。它需要实现两种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void snapshotState(FunctionSnapshotContext context) throws Exception;</span><br><span class="line">void initializeState(FunctionInitializationContext context) throws Exception;</span><br></pre></td></tr></table></figure></p><p>每当必须执行检查点时，snapshotState()都会被调用。每次初始化用户定义的函数时或者当函数从早期检查点恢复时,都会调用initializeState()。鉴于此，initializeState()不仅是初始化不同类型的状态，而且还用于状态恢复逻辑。</p><p>目前，Managed Operator State支持list-style(列表样式)。状态被认为是可序列化对象的列表，彼此独立，因此有资格在重新分配时进行再分配。根据状态访问方法，定义了以下再分配方案：</p><ul><li>Even-split redistribution：每个运算符返回一个状态元素列表。整个状态在逻辑上是所有列表的串联。在恢复-重新分配时，列表被平均分成与并行运算符一样多的子列表。每个运算符都会获得一个子列表，该子列表可以为空，也可以包含一个或多个元素。例如，如果使用并行性1，则运算符的检查点状态包含element1和element2；当将并行性增加到2时，element1可能最终在运算符实例0中，而element2将转到运算符实例1。</li><li>Union redistribution：每个运算符返回一个状态元素列表。整个状态在逻辑上是所有列表的串联。在恢复-重新分配时，每个运算符都会获得完整的状态元素列表。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;state&quot;&gt;&lt;a href=&quot;#state&quot; class=&quot;headerlink&quot; title=&quot;state&quot;&gt;&lt;/a&gt;state&lt;/h2&gt;&lt;p&gt;用Data Stream API编写的程序通常以各种形式保存状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows会在触发
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式数据流的轻量级异步快照</title>
    <link href="http://yoursite.com/2018/09/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%BC%82%E6%AD%A5%E5%BF%AB%E7%85%A7/"/>
    <id>http://yoursite.com/2018/09/14/分布式数据流的轻量级异步快照/</id>
    <published>2018-09-14T03:51:45.299Z</published>
    <updated>2018-09-14T13:54:35.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文章学习：</p><blockquote><p>Lightweight Asynchronous Snapshots for Distributed Dataﬂows</p></blockquote><p>分布式状态流处理其被用于云部署并执行大规模连续计算，致力于高吞吐和低延迟。这依靠于周期性全局状态快照，他有两个缺点：</p><pre><code>1. 由于影响了数据的摄入从而拖延了整体计算。2.他们坚持了存储所有传输和算子的状态，从而导致更大的快照。</code></pre><p>下面我们介绍Asynchronous Barrier Snapshotting (ABS，异步屏障快照)。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现有的所有分布式快照算法都把在通道中传输的记录或整个执行图中未处理的消息作为快照状态的一部分，这通常都不是必须的。<br>而对于ABS来说，并不会停止流的操作，仅仅有一点小的开销。<br>全局快照从理论上反映了执行图的整体状态或者其操作的一个特定实例的一个可能状态。</p><h2 id="Apache-Flink"><a href="#Apache-Flink" class="headerlink" title="Apache Flink"></a>Apache Flink</h2><p>当一个用户需要执行一个应用程序时，所有的流数据运算符都被编译为一个执行图，原则上是一个有向图G = (T,E) ，其中顶点T表示任务，边E表示数据通道。运算符的每个实例都封装在各自的任务(subtask)上。M表示在并行执行期间由任务传输的所有记录的集合。每一个t∈T都是封装运算符实例的独立执行并且由以下内容组成：</p><pre><code>1. 一组输入和输出管道 It,Ot ⊆ E;2. 一个运算符状态st ;3. 一个用户自定义函数(UDF)ft;</code></pre><p>对于执行过程来说，每一个task都需要消耗输入记录，更新自己的状态，并根据UDF生成新的记录。换种说法是，对于每条记录 r∈ M被任务t∈T接收，并生成一个新的状态和一组根据UDF ft:<br><img src="https://upload-images.jianshu.io/upload_images/13870799-dbc093747b23019f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="30%" height="30%"> 产生的新的输出D⊆M。</p><h2 id="ABS"><a href="#ABS" class="headerlink" title="ABS"></a>ABS</h2><p>我们定义了执行图G = (T,E)的一个全局快照<code>G*=(T*, E*)</code>作为所有任务和边的状态的集合，T<em>由运算符状态st</em>∈T<em>组成，其中t∈T，E</em>由通道状态e<em>∈E</em>组成，其中e∈E。</p><h4 id="非环状执行图的异步屏障快照"><a href="#非环状执行图的异步屏障快照" class="headerlink" title="非环状执行图的异步屏障快照"></a>非环状执行图的异步屏障快照</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1: upon event &lt;Init | input channels, output channels, fun, init state&gt; do // 事件发生&lt;触发操作 | 对象&gt;执行</span><br><span class="line">2:    blocked inputs:= 0; //阻塞管道数初始化0</span><br><span class="line">3:    inputs:= input channels; //初始化input为所有input管道数</span><br><span class="line">4:    outputs:= output channels; UDF := fun; //初始化output为所有输出管道数，初始化UDF</span><br><span class="line">5: </span><br><span class="line">6: upon event &lt;receive | input,&lt;barrier&gt;&gt; do //从某个input接收到barrier</span><br><span class="line">7:     if input != Nil then //当该input不是source时</span><br><span class="line">8:         blocked inputs := blocked inputs ∪ &#123;input&#125;; //将已经收到barrier的管道并入 blocked inputs并阻塞，其他管道继续接收。</span><br><span class="line">9:         trigger &lt;block | input&gt;; //触发阻塞barrier已经到达的管道</span><br><span class="line">10:   if blocked_inputs = inputs then //已收到barrier的管道数等于所有input端的管道数，即所有barrier已经到达</span><br><span class="line">11:       blocked_inputs:= 0; //置0</span><br><span class="line">12:       broadcast &lt;send | outputs,&lt;barrier&gt;&gt;; //向下游广播barrier</span><br><span class="line">13:       trigger&lt;snapshot | state&gt;; //触发快照，保存算子state</span><br><span class="line">14:       for each inputs as input </span><br><span class="line">15:           trigger &lt;unblock | input&gt;; //解锁所有input管道</span><br><span class="line">16: </span><br><span class="line">17: </span><br><span class="line">18: upon event &lt;receive | input, msg&gt; do//接受到正常消息时</span><br><span class="line">19:     &#123;state&apos;, out_records&#125; := UDF(msg, state); //计算新的状态值和输出记录</span><br><span class="line">20:     state := state&apos; ; //更新状态值</span><br><span class="line">21:     for each out_records as &#123;output,out_record&#125; </span><br><span class="line">22:         trigger &lt;send | output, out_record&gt;; //向下游发送经算子计算后的输出记录。</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13870799-68c6c98f72b58fb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>当通道被阻塞时，所有消息被缓冲，不会被传递，直到取消阻塞。</li><li>task可以在诸如block, unblock and send messages等通道组件上触发操作，所有输出通道都支持broadcasting messages。</li><li>在source被注入的消息被解析为一个”Nil”输入通道。</li></ul><p>中央协调员(JobManager中的一个进程)周期性的向所有source注入barrier。当一个source接受到barrier时，它会建立当前状态的快照并向下游广播。当非源算子接受到barrier时，它会阻塞该input channel，直到所有input都收到barrier后，该算子会保存当前状态的快照并向下游广播barrier。然后所有被block的input通道解除阻塞。<br>完整的全局快照 G<em>=(T</em>, E<em>) 将独自 由所有运算符的状态集T</em>组成，其中E* = 0。</p><h4 id="环状数据流的ABS"><a href="#环状数据流的ABS" class="headerlink" title="环状数据流的ABS"></a>环状数据流的ABS</h4><p>在有向循环图中使用上面的算法时，因为算子会无期限的等待接受所有输入管道的barrier，将不会停止，会导致死锁。<br>下面是适用于环状拓扑的ABS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1: upon event &lt;Init | input_channels, backedge_channels, output_channels, fun, init_state&gt; do </span><br><span class="line">2:     state:= init_state; marked := 0; </span><br><span class="line">3:     inputs:= input_channels; logging:= False; </span><br><span class="line">4:     outputs:= output_channels; UDF := fun; </span><br><span class="line">5:     loop_inputs:= backedge_channels; </span><br><span class="line">6:     state_copy:= Nil; backup_log:= []; </span><br><span class="line">7: </span><br><span class="line">8: upon event &lt;receive | input, &lt;barrier&gt;&gt; do </span><br><span class="line">9:     marked := marked∪&#123;input&#125;; </span><br><span class="line">10:     regular := inputs\loop_inputs; </span><br><span class="line">11:     if input != Nil AND input / ∈loop inputs then </span><br><span class="line">12:         trigger &lt;block | input&gt;; </span><br><span class="line">13:     if ¬logging AND marked = regular then </span><br><span class="line">14:         state_copy:= state;logging:= True; </span><br><span class="line">15:         broadcast &lt;send | outputs, &lt;barrier&gt;&gt;; </span><br><span class="line">16:         for each inputs as input </span><br><span class="line">17:             trigger &lt;unblock | input&gt;; </span><br><span class="line">18: </span><br><span class="line">19:     if marked = input_channels then </span><br><span class="line">20:         trigger &lt;snapshot | &#123;state_copy, backup_log&#125;&gt;; </span><br><span class="line">21:         marked := 0;logging:= False; </span><br><span class="line">22:         state_copy:= Nil;backup_log:= []; </span><br><span class="line">23: </span><br><span class="line">24: upon event &lt;receive|input, msg&gt; do </span><br><span class="line">25:     if logging AND node∈loop_inputs then </span><br><span class="line">26:         backup_log:= backup_log:: [input]; </span><br><span class="line">27:     &#123;state&apos;,out_records&#125;:= UDF(msg,state); </span><br><span class="line">28:     state:= state&apos;; </span><br><span class="line">29:     for each out_records as&#123;output,out_record&#125; </span><br><span class="line">30:         trigger &lt;send | output, out_record&gt;;</span><br></pre></td></tr></table></figure></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>在当前的实现中，blocked channels的所有输入数据被存储在磁盘上，而不是保存在内存中，以提高可伸缩性。</li><li>为了区分运算符状态和数据，我们引入了一个显式的OperatorState接口用于查询和更新状态。并且为Apache Flink的一些有状态的操作符(例如基于源的偏移量和聚合)提供了OperatorState实现。</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h4 id="ABS与全局同步快照算法比较"><a href="#ABS与全局同步快照算法比较" class="headerlink" title="ABS与全局同步快照算法比较"></a>ABS与全局同步快照算法比较</h4><p><img src="https://upload-images.jianshu.io/upload_images/13870799-14a0832b67388959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上述用于评估的执行拓扑图由六个不同运算符组成，并行度等于集群节点数目。source生成总计10亿条记录，在source实例间均匀分布。拓扑图中运算符的状态为每键(per-key)聚合和源偏移量。</p><p>在图2中, 我们描述了两个算法对基线 (Baseline) 的运行时影响。当快照的间隔较小时, 同步快照的性能影响尤为明显。这是由于系统花费更多的时间不处理任何数据, 以获取全局快照。ABS 对运行时的影响要低得多, 因为它连续运行而不阻塞总体执行, 同时保持相当稳定的吞吐量。对于更大的快照间隔, 同步算法的影响不那么显著, 因为它在我们的实验中以1-2 秒的时间运行, 同时让系统在其其余执行过程中以正常的吞吐量运转。</p><p>在图3中, 我们比较了运行 ABS 的拓扑的可伸缩性, 与基线的3秒快照间隔(无容错)相比。很明显, 基线作业和 ABS 都实现了线性可伸缩性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文章学习：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lightweight Asynchronous Snapshots for Distributed Dataﬂows&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分布式状态流处理其被用于云部署并执行大规模连续计算，致力于
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL 聚合函数与OVER</title>
    <link href="http://yoursite.com/2018/09/06/OVER/"/>
    <id>http://yoursite.com/2018/09/06/OVER/</id>
    <published>2018-09-06T14:16:53.645Z</published>
    <updated>2018-09-07T12:35:45.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="group-by与聚合函数-min-max-avg-sum-等"><a href="#group-by与聚合函数-min-max-avg-sum-等" class="headerlink" title="group by与聚合函数(min()/max()/avg()/sum()等)"></a>group by与聚合函数(min()/max()/avg()/sum()等)</h2><p>在使用 group by 子句时，select列表中的所有列必须是聚合列(SUM,MIN/MAX,AVG等)或着是 group by 子句中包括的列。如果在select列表中使用聚合列，其中必须只包括聚合列，否则必须有一个 group by 子句。</p><h2 id="窗口函数与聚合函数"><a href="#窗口函数与聚合函数" class="headerlink" title="窗口函数与聚合函数"></a>窗口函数与聚合函数</h2><p>聚合函数返回的各个分组的结果，窗口函数则为每一行返回结果。窗口函数在和当前行相关的一组表行上执行计算。 这相当于一个可以由聚合函数完成的计算类型。但不同于常规的聚合函数， 使用的窗口函数不会导致行被分组到一个单一的输出行，行保留其独立的身份。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select depname,empno, salary, avg(salary) over(partition by depname) </span><br><span class="line">from empsalary;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table><thead><tr><th style="text-align:center">depname</th><th style="text-align:center">empno</th><th style="text-align:center">salary</th><th style="text-align:center">avg          </th></tr></thead><tbody><tr><td style="text-align:center"> develop</td><td style="text-align:center">11</td><td style="text-align:center">5200</td><td style="text-align:center">5020.0000000000000000</td></tr><tr><td style="text-align:center"> develop</td><td style="text-align:center">7</td><td style="text-align:center">4200</td><td style="text-align:center">5020.0000000000000000</td></tr><tr><td style="text-align:center"> develop</td><td style="text-align:center">9</td><td style="text-align:center">4500</td><td style="text-align:center">5020.0000000000000000</td></tr><tr><td style="text-align:center"> develop</td><td style="text-align:center">8</td><td style="text-align:center">6000</td><td style="text-align:center">5020.0000000000000000</td></tr><tr><td style="text-align:center"> develop</td><td style="text-align:center">10</td><td style="text-align:center">5200</td><td style="text-align:center">5020.0000000000000000</td></tr><tr><td style="text-align:center"> personnel</td><td style="text-align:center">5</td><td style="text-align:center">3500</td><td style="text-align:center">3700.0000000000000000</td></tr><tr><td style="text-align:center"> personnel</td><td style="text-align:center">2</td><td style="text-align:center">3900</td><td style="text-align:center">3700.0000000000000000</td></tr><tr><td style="text-align:center"> sales</td><td style="text-align:center">3</td><td style="text-align:center">4800</td><td style="text-align:center">4866.6666666666666667</td></tr><tr><td style="text-align:center"> sales</td><td style="text-align:center">1</td><td style="text-align:center">5000</td><td style="text-align:center">4866.6666666666666667</td></tr><tr><td style="text-align:center"> sales</td><td style="text-align:center">4</td><td style="text-align:center">4800</td><td style="text-align:center">4866.6666666666666667</td></tr></tbody></table><p>前三列来自表格，第四列由avg得出，over使得将所有depname相同的行作为一个分区，求得其平均值赋给每一行。想一想如果使用group by会如何，按照depname分区？相同的depname行会被合并？select中的empno怎么办？</p><h2 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OVER (   </span><br><span class="line">      [ &lt;PARTITION BY clause&gt; ]  </span><br><span class="line">      [ &lt;ORDER BY clause&gt; ]    </span><br><span class="line">     )</span><br></pre></td></tr></table></figure><h3 id="partition-by"><a href="#partition-by" class="headerlink" title="partition by"></a>partition by</h3><p>将查询结果集划分为分区。窗口函数分别应用于每个分区，并对每个分区重新开始计算。</p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>定义结果集的每个分区中的行的逻辑顺序。也就是说，它指定执行窗口函数计算的逻辑顺序。</p><h2 id="over-与-group-by："><a href="#over-与-group-by：" class="headerlink" title="over() 与 group by："></a>over() 与 group by：</h2><p>对于group by来说，只能聚合group by中未包含的列的值。<br>然而，对于窗口聚合函数over()来说，你可以检索聚合和非聚合的值。</p><h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>下面是使用group by的实例，假设您需要计算每个值的总百分比，如果不使用窗口聚合函数，需要先生成聚合值表，然后把它加入原表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  table.id，</span><br><span class="line">  table.Value,</span><br><span class="line">  table.Value * 100.0 / tab.totalValue AS percentValue </span><br><span class="line">FROM orig </span><br><span class="line">INNER JOIN (</span><br><span class="line">  SELECT</span><br><span class="line">  id，</span><br><span class="line">  SUM(value) AS totalValue</span><br><span class="line">  FROM table </span><br><span class="line">  GROUP BY id </span><br><span class="line">  ) tab </span><br><span class="line">ON table.id = tab.id;</span><br></pre></td></tr></table></figure></p><p>如果使用over():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  id,</span><br><span class="line">  value,</span><br><span class="line">  value * 100.0 / SUM(value) OVER (PARTITION BY id) AS percentValue </span><br><span class="line">FROM table;</span><br></pre></td></tr></table></figure></p><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><h4 id="table："><a href="#table：" class="headerlink" title="table："></a>table：</h4><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">year</th><th style="text-align:center">color</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Ford</td><td style="text-align:center">2008</td><td style="text-align:center">White</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Chevy</td><td style="text-align:center">2005</td><td style="text-align:center">Green</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Ford</td><td style="text-align:center">2008</td><td style="text-align:center">Yellow</td></tr></tbody></table><h4 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  year,</span><br><span class="line">  color ,</span><br><span class="line">  COUNT(*) OVER (PARTITION BY year) AS count </span><br><span class="line">FROM table</span><br><span class="line">ORDER BY id;</span><br></pre></td></tr></table></figure><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">year</th><th style="text-align:center">color</th><th style="text-align:center">count</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Ford</td><td style="text-align:center">2008</td><td style="text-align:center">White</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Chevy</td><td style="text-align:center">2005</td><td style="text-align:center">Green</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Ford</td><td style="text-align:center">2008</td><td style="text-align:center">Yellow</td><td style="text-align:center">2</td></tr></tbody></table><p>在没有group by的情况下进行了行的聚合，如果使用group by：</p><h4 id="查询：-1"><a href="#查询：-1" class="headerlink" title="查询："></a>查询：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  year,</span><br><span class="line">  color ,</span><br><span class="line">  COUNT(*) AS count </span><br><span class="line">FROM table </span><br><span class="line">GROUP BY year, id, name, color  </span><br><span class="line">ORDER BY id;</span><br></pre></td></tr></table></figure><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">year</th><th style="text-align:center">color</th><th style="text-align:center">count</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Ford</td><td style="text-align:center">2008</td><td style="text-align:center">White</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Chevy</td><td style="text-align:center">2005</td><td style="text-align:center">Green</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Ford</td><td style="text-align:center">2008</td><td style="text-align:center">Yellow</td><td style="text-align:center">1</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;group-by与聚合函数-min-max-avg-sum-等&quot;&gt;&lt;a href=&quot;#group-by与聚合函数-min-max-avg-sum-等&quot; class=&quot;headerlink&quot; title=&quot;group by与聚合函数(min()/max()/avg(
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简介</title>
    <link href="http://yoursite.com/2018/09/02/Introduction/"/>
    <id>http://yoursite.com/2018/09/02/Introduction/</id>
    <published>2018-09-02T05:59:25.457Z</published>
    <updated>2018-09-02T06:03:59.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是-的个人博客。"><a href="#这是-的个人博客。" class="headerlink" title="这是***的个人博客。"></a>这是***的个人博客。</h1><h2 id="原文章地址-Essay"><a href="#原文章地址-Essay" class="headerlink" title="原文章地址: Essay"></a>原文章地址: <a href="http://www.cnblogs.com/ooffff/" target="_blank" rel="noopener">Essay</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这是-的个人博客。&quot;&gt;&lt;a href=&quot;#这是-的个人博客。&quot; class=&quot;headerlink&quot; title=&quot;这是***的个人博客。&quot;&gt;&lt;/a&gt;这是***的个人博客。&lt;/h1&gt;&lt;h2 id=&quot;原文章地址-Essay&quot;&gt;&lt;a href=&quot;#原文章地址-Essa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/02/hello-world/"/>
    <id>http://yoursite.com/2018/09/02/hello-world/</id>
    <published>2018-09-02T00:24:47.781Z</published>
    <updated>2018-09-02T00:24:47.781Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
