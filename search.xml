<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown语法格式]]></title>
    <url>%2F2019%2F03%2F17%2FMarkdown%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文参照：https://help.github.com/en/categories/writing-on-github 标题要创建标题，就在文本前面添加1~6个#符号。 示例： 12# 一级标题## 二级标题 文本样式粗体将要使用粗体的文本用**包括。 示例： 1**This is bold text** 斜体将要使用粗体的文本用*包括。 示例： 1*This text is italicized* 删除线将要使用粗体的文本用~~包括。 示例： 1~~This was mistaken text~~ 引用使用&gt;引用一段文本。 示例： 1&gt; This is quoting text 引用代码使用 ` 包括引用的代码行。 使用 ``` 包括引用的代码块。 示例： 1234567\`This is the line of code\`\​`\`\`These are the code blocksThese are the code blocksThese are the code blocks​\`\`\` 链接在方括号中包装链接文本[ ]，然后将URL包装在圆括号中来创建内联链接( )。 示例： 1This is [text](https://gqbbbb.github.io/). 列表无序列表把-或*放在行前来表示无序列表。 示例： 123- George Washington- John Adams- Thomas Jefferson 有序列表把数字+.放在行前来表示有序列表。 示例： 1231. George Washington2. John Adams3. Thomas Jefferson 嵌套列表在嵌套列表项前面键入空格字符，直到列表标记字符（-或*）位于其上方项目中文本的第一个字符的正下方。 示例： 1231. First list item - First nested list item - Second nested list item 任务列表要创建任务列表，请在列表标记字符（-或*）后加上[+空格+]。要将任务标记为完成，请用x代替空格（[x]）。 示例： 12- [ ] Is empty- [x] Selected 如果任务列表项描述以括号开头，则需要使用命令\对其进行转义： 示例： 1- [ ] \(Optional) Open a followup issue 表格可以使用管道|和连字符-创建表。连字符用于创建每个列的标题，而管道用于分隔每个列。 示例： 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | 单元格的宽度可以不同，并且不需要在列内完美对齐。标题行的每列中必须至少有三个连字符。 示例： 1234| First Header | Second Header || --- | ----- || Content Cell | Content Cell || Content Cell | Content Cell | 可以通过在连字符的左侧，右侧或两侧包含冒号:来将文本对齐到列的左侧，右侧或中心。 要在您的单元格中包含管道|作为内容，请在管道前使用\进行转义。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5]]></title>
    <url>%2F2019%2F03%2F09%2FH5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是H5？ HTML5是一种超文本标记语言，用于在万维网上构建和呈现网页内容。 示例123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My First Heading&lt;/h1&gt;&lt;p&gt;My first paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt;指该文件为HTML5，不区分大小写， 指这是一个HTML页面根元素， 元素包含该文档元信息， 元素指该文档标题， 元素指该文档可见页面， 元素定义了一个大的标题 元素定义了一个段落 标签&lt;标记名&gt; 内容 &lt;/标记名&gt;浏览器不显示HTML标记，但使用它们来确定如何显示文件，只有在body中的内容才会被显示在浏览器中。 文档 文档开头必须使用文档类型开始：&lt;!DOCTYPE html&gt;。 必须以开头和结尾。 可见部分为和之间的。 到标签定义HTML标题。 用定义段落。 用定义图片，src=源文件，alt=当无法显示图像时替代文本，width和height为图片宽度高度，例如： style属性被用于指定一个元素的造型，如颜色，字体，大小等，例如：I am a paragraph。 lang属性用于声明语言，可用在，例如：。 title属性被添加到或元件。当您将鼠标放在段落上时，title属性的值将显示为提示信息，例如：This is a paragraph.。 html并不区分大小写，建议使用小写；引号尽量不要省略；当出现双引号时可以在外面套上单引号，出现单引号可以在外面套上双引号，例如：和。 &lt;hr&gt;元件用于在HTML页中分离内容，具体显示为一条水平线，没有结束标记。 &lt;br&gt;元素定义换行，没有结束标记。 元素定义预格式化文本，在该元素里面的文本被定义为一个等宽字体，并且它保留了等宽和换行。head该HTML元素与标题无关。该元素是元数据的容器。HTML元数据是关于HTML文档的数据。元数据并不显示。该元件放置在之间标签和。段落随着调整窗口大小将产生不同的结果，在显示页面时，浏览器将删除任何多余的空格和行。样式 样式属性： tagname：标签名称；style：属性。 背景颜色：background-color属性定义HTML元素的背景颜色，放在中默认整个页面背景颜色，放在中默认文本范围内背景颜色，放在中默认该文本的背景颜色，若没有设置而中设置了，则默认设置为整个页面背景颜色，例如，设置页面为灰蓝色。 文本颜色：color属性定义HTML元素的文本颜色，注意与背景颜色的区别。例如：This is a headingThis is a paragraph. 字体种类：font-family属性定义字体种类，例如This is a headingThis is a paragraph.。 text-align定义文本水平对齐，例如：Centered paragraph.。 font-size属性定义文本字体大小，例如：This is a heading。格式格式元素被设计为显示特殊类型的文本： ：加粗字体，例如：This text is bold.。 ：斜体，例如：This text is italic.。 ：下划线， ：重要文本(变粗)，例如：This text is strong.。 ：强调的文字(变倾斜)，例如：This text is emphasized. ：标记的文本，mark后的文本背景变黄。 ：小文本，例如：HTML Small Formatting。 ：删除的文字，文本上会显示一条横线。 ：插入文本，文本下显示下划线，例如：My favorite color is red.，color下加下划线。 &lt;sub&gt;：下标文本，例如：&lt;p&gt;This is &lt;sub&gt;subscripted&lt;/sub&gt;.&lt;/p&gt;。 &lt;sup&gt;：上标文本，例如：&lt;p&gt;This is &lt;sup&gt;superscripted&lt;/sup&gt; text.&lt;/p&gt;。 ：行内元素，没有任何特殊语义。可以通过使用类或者Id属性使用它来编组元素以达到某种样式意图 浏览器中显示和，和相同。但是 和定义粗体和斜体文字， 和意味着该文本是重要的。 特殊字符 原义字符 等价字符引用 &lt; &amp;lt &gt; &amp;gt “ &amp;quot ‘ &amp;apos &amp; &amp;amp 123&lt;p&gt;In HTML, you define a paragraph using the &lt;p&gt; element.&lt;/p&gt;&lt;p&gt;In HTML, you define a paragraph using the &amp;lt;p&amp;gt; element.&lt;/p&gt; //注意字符引用后的分号。 123In HTML, you define a paragraph using theelement.In HTML, you define a paragraph using the &lt;p&gt; element. 列表 无序列表 中项目的顺序并不重要，就像购物列表。这些内容被包括在一个&lt; ul&gt;( 代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的。通常情况下，无序列表项的头部可以是几种形式，如一个点，一个圆形或方形。头部的风格并不是在页面的HTML描述定义, 但在其相关的CSS 可以用 list-style-type 属性。) 元素里。 有序列表中项目的顺序很重要，就像一个食谱。这些内容被包括在一个元素里(表示多个有序列表项，通常渲染为有带编号的列表。) 元素里。 列表内的每个项目被包括在一个 (用于表示列表里的条目。它必须被包含在一个父元素里：一个有顺序的列表()，一个无顺序的列表()，或者一个菜单 ()。)在菜单或者无顺序的列表里，列表条目通常用点排列显示。在有顺序的列表里，列表条目通常是在左边有按升序排列计数的显示，例如数字或者字母。”) (list item) 元素里。 注释注释是被浏览器忽略的，而且是对用户不可见的，用特殊的记号包括起来，例如：1&lt;!-- &lt;p&gt;I am!&lt;/p&gt; --&gt; 开发者工具Ctrl + Shift + I 打开开发工具套件，检查当前加载的HTML、CSS和JavaScript，显示每个资源页面的请求以及载入所花费的时间。 HTML中的CSS和JavaScript ，这个元素最常于链接样式表， 元素经常位于文档的头部，rel=”stylesheet”，表明这是样式表，而 href包含了样式表文件的路径：。 元素用于嵌入或引用可执行脚本。没必要非要放在文档头部；实际上，把它放在文档的尾部（在 标签之前`）是一个更好的选择 ，这样可以确保在加载脚本之前浏览器已经解析了HTML内容。 超链接用定义，例如： 触发链接的元素(可以使一句话或者一个块级元素) 。 超链接可以链接到html文档的特定部分，而不仅仅是文件的顶部。 要做到这一点你必须首先给要链接的元素分配一个id属性。 Mailing address 然后链接到那个特定的id，您可以在URL的结尾包含它，前面是一个井号(#)。 Want to write us a letter? Use our mailing address. 甚至可以用链接到同一份文件的另一部分。 The company mailing address can be found at the bottom of this page. 当链接到要下载的资源时, 可以使用下载属性来提供一个默认的保存文件名。 Download Latest Firefox for Windows (64-bit) (English, US) 描述列表描述列表使用与其他列表类型不同的闭合标签，它是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。 此外，每一项都用 元素 （或 HTML 术语定义元素）闭合。该元素仅能作为 的子元素出现。通常在该元素后面会跟着 元素， 然而，多个连续出现的 元素都将由出现在它们后面的第一个 元素定义。一个可以同时有多个描述。例如：12345678&lt;dl&gt; &lt;dt&gt;soliloquy&lt;/dt&gt; &lt;dd&gt;In drama, where a character speaks to themselves, representing their inner thoughts or feelings and in the process relaying them to the audience (but not to other characters.)&lt;/dd&gt; &lt;dt&gt;monologue&lt;/dt&gt; &lt;dd&gt;In drama, where a character speaks their thoughts out loud to share them with the audience and any other characters present.&lt;/dd&gt; &lt;dt&gt;aside&lt;/dt&gt; &lt;dd&gt;In drama, where a character shares a comment only with the audience for humorous or dramatic effect. This is usually a feeling, thought or piece of additional background information.&lt;/dd&gt;&lt;/dl&gt; 引用块引用如果一个块级内容（一个段落、多个段落、一个列表等）从其他地方被引用，你应该把它用元素包括起来，代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进。若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 属性上。若要以文本方式包括，则要用元素包括。例如：1234&lt;blockquote cite=&quot;https://example.com&quot;&gt; &lt;p&gt;The &lt;strong&gt;HTML &lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt; Element&lt;/strong&gt; (or &lt;em&gt;HTML Block Quotation Element&lt;/em&gt;) indicates that the enclosed text is an extended quotation.&lt;/p&gt;&lt;/blockquote&gt; 行内引用使用元素进行行内引用，元素旨在用于不需要分段的短引用。会自动加上引号。例如：12&lt;p&gt;The quote element — &lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt; — is &lt;q cite=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt;intendedfor short quotations that don&apos;t require paragraph breaks.&lt;/q&gt;&lt;/p&gt; 缩略语它常被用来包裹一个缩略语或缩写，并且提供缩写的解释(包含在title属性中)。当鼠标移动到上时会出现提示。例如：1&lt;p&gt;This is &lt;abbr title=&quot;Hypertext Markup Language&quot;&gt;HTML&lt;/abbr&gt;.&lt;/p&gt; 标记联系方式用标记联系方式。 标记代码块 ：用于标记计算机通用代码。 ：保留的空格（通常是代码块）——如果您在文本中使用缩进或多余的空白，浏览器将忽略它，您将不会在呈现的页面上看到它。但是，如果您将文本包含在标签中，那么空白将会以与你在文本编辑器中看到的相同的方式渲染出来。 ：用于标记具体变量名。 ：用于标记输入电脑的键盘（或其他类型）输入。 ：用于标记计算机程序的输出。例如：12345678910111213141516&lt;pre&gt;&lt;code&gt;var para = document.querySelector(&apos;p&apos;);para.onclick = function() &#123; alert(&apos;Owww, stop poking me!&apos;);&#125;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You shouldn&apos;t use presentational elements like &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In the above JavaScript example, &lt;var&gt;para&lt;/var&gt; represents a paragraph element.&lt;/p&gt;&lt;p&gt;Select all the text with &lt;kbd&gt;Ctrl&lt;/kbd&gt;/&lt;kbd&gt;Cmd&lt;/kbd&gt; + &lt;kbd&gt;A&lt;/kbd&gt;.&lt;/p&gt;&lt;pre&gt;$ &lt;kbd&gt;ping mozilla.org&lt;/kbd&gt;&lt;samp&gt;PING mozilla.org (63.245.215.20): 56 data bytes64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms&lt;/samp&gt;&lt;/pre&gt; 1234567891011121314var para = document.querySelector(&apos;p&apos;);para.onclick = function() &#123; alert(&apos;Owww, stop poking me!&apos;);&#125;You shouldn&apos;t use presentational elements like &lt;font&gt; and &lt;center&gt;.In the above JavaScript example, para represents a paragraph element.Select all the text with Ctrl/Cmd + A.$ ping mozilla.orgPING mozilla.org (63.245.215.20): 56 data bytes64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms 标记时间用标记可以被机器识别的时间，例如：1&lt;time datetime=&quot;2016-01-20&quot;&gt;20 January 2016&lt;/time&gt; datetime可以被识别。 标记联系人信息HTML有一个用于标记联系人详细信息的元素 -，简单地包含了您的联系方式，但要记住的一点是，该元素用于标记编写HTML文档的人员的联系人详细信息，而不是任何地址。 用于结构化网站的HTML 标题:元素表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。 导航栏: 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。 主要内容: 元素呈现了文档或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。这部分内容在文档中应当是独一无二的，不包含任何在一系列文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。具有代表性的内容段落主题可以使用，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。元素表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (- element) 作为子节点 来 辨识每一个。元素是一个通用型的流内容容器，它在语义上不代表任何特定类型的内容，它可以被用来对其它元素进行分组，一般用于样式化相关的需求（使用 class 或 id 特性) 或者对具有相同特性的一组元素进行分组 (比如 lang)，它应该在没有任何其它语义元素可用时才使用 (比如 或 ) 侧栏:元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。经常嵌套在中。 页脚: 元素表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。 视频和音频视频通过123&lt;video src=&quot;video1.webm&quot; controls&gt; &lt;p&gt;If your browser doesn&apos;t support HTML5 video. Here is a &lt;a href=&quot;video1.webm&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt; &lt;/video&gt; 在页面中加入视频。 src：视频URL。 controls：控制视频或音频播放。 内的：当浏览器不支持video的格式时展现出来。 多格式支持12345&lt;video controls&gt; &lt;source src=&quot;video1.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;video1.webm&quot; type=&quot;video/webm&quot;&gt; &lt;p&gt;If your browser doesn&apos;t support HTML5 video. Here is a &lt;a href=&quot;video1.mp4&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt;&lt;/video&gt; 将 src 属性从 标签中移除，转而将它放在几个单独的标签当中。在这个例子当中，浏览器将会检查 标签，并且播放第一个与其自身 codec(解码器) 相匹配的媒体。你的视频应当包括 WebM 和 MP4 两种格式，这两种在目前已经足够支持大多数平台和浏览器。 每个 标签页含有一个 type 属性，这个属性是可选的，但是建议你添加上这个属性 — 它包含了视频文件的 MIME types(媒体类型/内容类型)，同时浏览器也会通过检查这个属性来迅速的跳过那些不支持的格式。如果你没有添加 type 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这样会消耗掉大量的时间和资源。 其他属性 width和height：控制视频的尺寸，但是video总会保持它原始的长宽比 — 也叫做纵横比。如果你设置的尺寸没有保持视频原始长宽比，那么视频边框将会拉伸，而未被视频内容填充的部分，将会显示默认的背景颜色。 autoplay：即使页面的其他部分还没有加载完全，也会使音频和视频立即播放。 loop：使音频或者视频循环播放。 muted：会使媒体播放时，默认关闭声音。 poster：指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或广告。 preload：被用来缓冲较大的文件，有3个值可选：1. none：不缓冲。 2. auto：页面加载后缓存媒体文件。 3. metadata：仅缓冲文件的元数据。 1234567&lt;video controls width=&quot;400&quot; height=&quot;400&quot; autoplay loop muted poster=&quot;poster.png&quot;&gt; &lt;source src=&quot;video1.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;video1.webm&quot; type=&quot;video/webm&quot;&gt; &lt;p&gt;If your browser doesn&apos;t support HTML5 video. Here is a &lt;a href=&quot;video1.mp4&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt;&lt;/video&gt; 音频通过12345&lt;audio controls&gt; &lt;source src=&quot;audio1.mp3&quot; type=&quot;audio/mp3&quot;&gt; &lt;source src=&quot;audio1.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;p&gt;If your browser doesn&apos;t support HTML5 audio. Here is a &lt;a href=&quot;audio1.mp3&quot;&gt;link to the audio&lt;/a&gt; instead.&lt;/p&gt;&lt;/audio&gt; 加入音频。 audio不支持width/height和poster。其他同video。 如何显示音轨文本通过添加音频副本的方式添加字幕。 WebVTT 是一个格式，用来编写文本文件，这个文本文件包含了众多的字符串，这些字符串会带有一些元数据，它们可以用来描述这个字符串将会在视频中显示的时间，甚至可以用来描述这些字符串的样式以及定位信息。这些字符串叫做 cues ，你可以根据不同的需求来显示不同的样式，最常见的如下： subtitle：通过添加翻译字幕，来帮助那些听不懂人们理解音频当中的内容。 captions：同步翻译对白，或是描述一些有重要信息的声音，来帮助那些不能听音频的人们理解音频中的内容。 timed descriptions：将文字转换为音频，用于服务那些有视觉障碍的人。 以 .vtt 后缀名保存文件。 用标签链接 .vtt 文件，标签需放在 或 标签当中，同时需要放在所有 标签之后。使用kind属性来指明是哪一种类型，如 subtitles 、 captions 、 descriptions。然后，使用 srclang来告诉浏览器你是用什么语言来编写的 subtitles。 例如：12345&lt;video controls&gt; &lt;source src=&quot;example.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;example.webm&quot; type=&quot;video/webm&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;subtitles_en.vtt&quot; srclang=&quot;en&quot;&gt;&lt;/video&gt; 嵌入元素允许您将其他Web文档嵌入到当前文档中。 例如：1234567&lt;iframe src=&quot;https://example.com&quot; width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen sandbox&gt; &lt;p&gt; &lt;a href=&quot;https://example.com&quot;&gt; Fallback link for browsers that don&apos;t support iframes &lt;/a&gt; &lt;/p&gt;&lt;/iframe&gt; src：要嵌入文档的URL。 width和height：指定想要的iframe的宽度和高度。 allowfullscreen：可以通过全屏API设置为全屏模式. frameborder：如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，默认。0删除边框。 sandbox 在沙盒中运行，可以提高安全性设置。 和用于嵌入视频，SVG，图像甚至Flash SVGSVG是用于描述矢量图像的XML语言。 位图：使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.) 矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 SVG格式可以让我们创造用于 Web 的精彩的矢量图形。 可以通过嵌入。不过将无法使用JavaScript操作图像。如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。 SVG内联，在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中，确保您的SVG代码在标签中。内联SVG是唯一可以让您在SVG图像上使用CSS交互. 自适应图片1234567&lt;img srcset=&quot;elva-fairy-320w.jpg 320w, elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w&quot; sizes=&quot;(max-width: 320px) 280px, (max-width: 480px) 440px, 800px&quot; src=&quot;elva-fairy-800w.jpg&quot; alt=&quot;Elva dressed as a fairy&quot;&gt; srcset：定义了我们允许浏览器选择的图像集，以及每个图像的大小；文件名+空格+图像的固有宽度（以像素为单位）。 sizes：定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。；媒体条件+空格+槽的宽度。 12345&lt;picture&gt; &lt;source type=&quot;image/svg+xml&quot; srcset=&quot;pyramid.svg&quot;&gt; &lt;source type=&quot;image/webp&quot; srcset=&quot;pyramid.webp&quot;&gt; &lt;img src=&quot;pyramid.png&quot; alt=&quot;regular pyramid built from four equilateral triangles&quot;&gt;&lt;/picture&gt; 可以使用picture来进行图片格式的选择 表格1234567891011&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Company&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Apple, Inc.&lt;/td&gt; &lt;td&gt;1 Infinite Loop Cupertino, CA 95014&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格用table元素包括。 由th元素创建的表头单元格，包含表头信息。 由td元素创建的标准单元格，包含数据。th元素内部的文本通常会呈现为居中的粗体文本，而td元素内的文本通常是左对齐的普通文本。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA博客文章收藏]]></title>
    <url>%2F2019%2F03%2F09%2FJAVA%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[动态绑定与静态绑定 隐藏和覆盖 为什么子类一定要访问父类中的构造函数 关于static和static+final的区别，以及编译阶段的常量传播优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[XV6环境配置]]></title>
    <url>%2F2019%2F03%2F09%2FXV6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MIT 6.828 需要使用两种工具：x86模拟器：qemu 和 编译器工具链。 环境Ubuntu18.04 测试编译器工具链###第一步： $ objdump -i 第二行应该为 elf32-i386。我的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137BFD 头文件版本 (GNU Binutils for Ubuntu) 2.30elf64-x86-64 (header 小端序, data 小端序) i386elf32-i386 (header 小端序, data 小端序) i386elf32-iamcu (header 小端序, data 小端序) iamcuelf32-x86-64 (header 小端序, data 小端序) i386a.out-i386-linux (header 小端序, data 小端序) i386pei-i386 (header 小端序, data 小端序) i386pei-x86-64 (header 小端序, data 小端序) i386elf64-l1om (header 小端序, data 小端序) l1omelf64-k1om (header 小端序, data 小端序) k1omelf64-little (header 小端序, data 小端序) i386 l1om k1om iamcu pluginelf64-big (header 大端序, data 大端序) i386 l1om k1om iamcu pluginelf32-little (header 小端序, data 小端序) i386 l1om k1om iamcu pluginelf32-big (header 大端序, data 大端序) i386 l1om k1om iamcu pluginpe-x86-64 (header 小端序, data 小端序) i386pe-bigobj-x86-64 (header 小端序, data 小端序) i386pe-i386 (header 小端序, data 小端序) i386plugin (header 小端序, data 小端序)srec (header 未知的端序, data 未知的端序) i386 l1om k1om iamcu pluginsymbolsrec (header 未知的端序, data 未知的端序) i386 l1om k1om iamcu pluginverilog (header 未知的端序, data 未知的端序) i386 l1om k1om iamcu plugintekhex (header 未知的端序, data 未知的端序) i386 l1om k1om iamcu pluginbinary (header 未知的端序, data 未知的端序) i386 l1om k1om iamcu pluginihex (header 未知的端序, data 未知的端序) i386 l1om k1om iamcu plugin elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 a.out-i386-linux i386 elf64-x86-64 elf32-i386 ----------- elf32-x86-64 a.out-i386-linux l1om ------------ ---------- ----------- ------------ ---------------- k1om ------------ ---------- ----------- ------------ ---------------- iamcu ------------ ---------- elf32-iamcu ------------ ---------------- plugin ------------ ---------- ----------- ------------ ---------------- pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big i386 pei-i386 pei-x86-64 ---------- ---------- elf64-little elf64-big l1om -------- ---------- elf64-l1om ---------- elf64-little elf64-big k1om -------- ---------- ---------- elf64-k1om elf64-little elf64-big iamcu -------- ---------- ---------- ---------- elf64-little elf64-big plugin -------- ---------- ---------- ---------- elf64-little elf64-big elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 plugin srec i386 elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 ------ srec l1om elf32-little elf32-big --------- ---------------- ------- ------ srec k1om elf32-little elf32-big --------- ---------------- ------- ------ srec iamcu elf32-little elf32-big --------- ---------------- ------- ------ srec plugin elf32-little elf32-big --------- ---------------- ------- ------ srec symbolsrec verilog tekhex binary ihex i386 symbolsrec verilog tekhex binary ihex l1om symbolsrec verilog tekhex binary ihex k1om symbolsrec verilog tekhex binary ihex iamcu symbolsrec verilog tekhex binary ihex plugin symbolsrec verilog tekhex binary ihex 第二步 $ gcc -m32 -print-libgcc-file-name 应该输出： / usr / lib / gcc / i486-linux-gnu / version /libgcc.a 或 / usr / lib / gcc / x86_64-linux-gnu / version /32/libgcc.a 我的： /usr/lib/gcc/x86_64-linux-gnu/6/32/libgcc.a 关于GCC版本的问题，默认安装的是7，但是后面会出现问题，稍后再说。 QEMU安装的qemu是修订版本，不是发行版。克隆6.828 QEMU git存储库。 git clone https://github.com/mit-pdos/6.828-qemu.git qemu 速度有点慢，不过还行，洗把脸的功夫。 可能需要安装下面这些包：1234$ sudo apt-get install libglib2.0-dev$ sudo apt-get install libz-dev$ sudo apt-get install libpixman-1-dev$ sudo apt-get install libsdl1.2-dev 我最后一个包缺少依赖安装不成功，不要管，继续。克隆完成后，切换到qemu主目录 $ cd qemu 配置 $ sudo ./configure –prefix=/usr/local –target-list=”i386-softmmu x86_64-softmmu” 安装 $sudo make &amp;&amp; sudo make install 下面是重点 发生的error1.”major”和”minor”1234567quotactl.c: In function ‘find_home_device’:quotactl.c:31:13: error: In the GNU C Library, &quot;major&quot; is defined by &lt;sys/sysmacros.h&gt;. For historical compatibility, it is currently defined by &lt;sys/types.h&gt; as well, but we plan to remove this soon. To use &quot;major&quot;, include &lt;sys/sysmacros.h&gt; directly. If you did not intend to use a system-defined macro &quot;major&quot;, you should undefine it after including &lt;sys/types.h&gt;. 这是因为major被定义在&lt;sys/sysmacros.h&gt;，由于历史兼容性&lt;sys/types.h&gt;也有定义，但是要被移除了，所以你应该在头文件包括&lt;sys/sysmacros.h&gt;。打开commands-posix.c $ vim commands-posix.c 添加 #include &lt;sys/sysmacros.h&gt;重新执行 2.’%s’12blkdebug.c:693:31: error: &apos;%s&apos; directive output may be truncated writing up to 4095 bytes into a region of size 4086 [-Werror=format-truncation=] 这个好像时因为GCC版本过高(7)，对printf输出更加严格，直接把GCC改为612345678$ sudo update-alternatives --remove-all gcc $ sudo update-alternatives --remove-all g++$ sudo apt-get install gcc-6$ sudo apt-get install gcc-6$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc6 100$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 100$ sudo update-alternatives --config gcc$ sudo update-alternatives --config gcc 最后gcc -v查看版本再次make &amp;&amp; make install 克隆6.828源码123mkdir ~/6.828cd ~/6.828git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab 切换到lab目录下 make 生成一个kernel.img make qemu 可能出现的错误可能会有”undefined reference to `__udivdi3’错误，你需要取下载对应版本的multilib。 $sudo apt-get install gcc-6-multilib g++-6-multilib 重新make qemu出现123456789101112131415161718qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log VNC server running on `127.0.0.1:5900&apos;6828 decimal is XXX octal!entering test_backtrace 5entering test_backtrace 4entering test_backtrace 3entering test_backtrace 2entering test_backtrace 1entering test_backtrace 0leaving test_backtrace 0leaving test_backtrace 1leaving test_backtrace 2leaving test_backtrace 3leaving test_backtrace 4leaving test_backtrace 5Welcome to the JOS kernel monitor!Type &apos;help&apos; for a list of commands.K&gt; 即安装成功！]]></content>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F12%2F23%2FC%2F</url>
    <content type="text"><![CDATA[scanf �� gets ������scanf�� ���ܽ��ܿո��Ʊ��Tab���س��ȣ� �������س����ո��tab�����Զ����ַ���������� ‘\0’�����ǻس����ո��tab���Ի���������Ļ������С� gets: �ܹ����ܿո��Ʊ��Tab�ͻس��ȣ� �ɽ��ܻس���֮ǰ����������ַ������� ‘\0’ ��� ‘\n’ ���س������������뻺�����С�]]></content>
  </entry>
  <entry>
    <title><![CDATA[状态管理]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[state用Data Stream API编写的程序通常以各种形式保存状态： Windows会在触发元素或聚合之前收集元素或聚合 转换函数可以使用键/值状态接口来存储值 转换函数可以实现CheckpointedFunction接口以使其局部变量具有容错能力。 状态如何在内部表示，以及如何以及如何在检查点上持久化，取决于所选的状态后端。 状态后端Flink捆绑了这些状态后端： MemoryStateBackend (默认) FsStateBackend RocksDBStateBackend MemoryStateBackend默认以java堆的对象形式保存数据，Key/value状态和窗口运算中的数据，用hash表来存储值、触发器等信息。基于checkpoints接口的方式，状态后端将对状态进行快照，并作为检查点的一部分，发送通知给JobManager (master)，这些数据同样存储在java堆中。 FsStateBackend可以通过一个文件系统的URL来配置(type, address, path), 例如 :”hdfs://namenode:40010/flink/checkpoints”或者 “file:///data/flink/checkpoints”。FsStateBackend将正在运行的数据保存TaskManager内存中。 在做检查点时, 它将包含状态的快照信息写入配置好的文件系统目录中，. 最小的元数据信息被存储到JobManager的内存中。 RocksDBStateBackend可以通过一个文件系统的URL来配置(type, address, path), 例如 :”hdfs://namenode:40010/flink/checkpoints”或者 “file:///data/flink/checkpoints”。FsStateBackend将正在运行的数据保存TaskManager内存中，存储到RocksDB(http://rocksdb.org/) 数据库中. 在做检查点时, 所有RocksDB数据库的数据将通过检查点保存到文件系统目录中，. 最小的元数据信息被存储到JobManager的内存中。 Keyed State and Operator State：键控state：基于KeyedStream上的状态，与key绑定。可以将Keyed State看成已经被分区的Operator State，每个key都有一个状态分区。每一个keyed-state都绑定了唯一的一个&lt;parallel-operator-instance, key&gt;。因为每个key都属于一个 keyed operator的并行实例，所以我们可以把它看作是&lt;operator, key&gt;。 算子state：Operator State跟一个特定operator的一个并发实例绑定，整个operator只对应一个state。而一个operator上可能会有多个key，对应多个keyed state。Kafka Connector就是在Flink中使用Operator State的一个很好的例子，每个Kafka consumer的并行实例保存着一个topic分区和偏移量的映射作为它的Operator state。 Raw and Managed State键控state和算子state有两种存在形式：原始状态和托管状态。 raw state即原始状态，由用户自行管理具体的数据结构的状态，使用byte[]来读写状态内容，写到检查点，对其内部数据结构一无所知。 managed state托管状态，是由Flink框架管理的状态，由Flink运行时控制的数据结构表示，例如内部哈希表或RocksDB，Flink的runtime对状态进行编码并将它们写入检查点。DataStream上推荐使用托管状态，当实现一个用户自定义的operator时，会使用到原始状态。 Using Managed Keyed Statemanaged keyed state接口提供了对不同类型状态 (当前输入元素的key的) 的访问，这种类型的状态只能运用在KeyedStream (通过stream.keyBy(…)生成)。几种不同类型的状态： ValueState：保留了一个可以更新和检索的值，比如通过key查出对应的值，使用update(T)来更新值，T value()设置该值。 ListState：可以追加元素并检索Iterable (迭代)所有当前存储的元素，使用add(T)或addAll(List)添加元素，可以使用Iterable检索Iterable get()。您也可以使用update(List)覆盖现有列表。 ReducingState：这保留一个值，表示添加到状态的所有值的聚合，使用add(T)添加的元素简化为使用ReduceFunction的一个集合。 AggregatingState&lt;IN, OUT&gt;：这保留了一个单独的值，它代表了添加到该状态的所有值的聚合。与ReducingState相反，聚合类型可能不同于添加到该状态的元素类型，add(IN)添加的元素是使用指定的AggregateFunction聚合的。 FoldingState&lt;T, ACC&gt;: 这保留了一个单独的值，它代表了添加到该状态的所有值的聚合。与ReducingState相反，聚合类型可能不同于添加到该状态的元素类型，add(IN)添加的元素是使用指定的FoldFunction聚合的。 MapState&lt;UK, UV&gt;: 这将保留映射列表。您可以将key-value对放入状态，并检索Iterable所有当前存储的映射。使用put(UK, UV)或 putAll(Map&lt;UK, UV&gt;)添加映射。可以使用检索与用户key关联的值get(UK)。对于映射，可以使用entries()，keys()和values()分别检索映射，键和值的迭代视图。可以用clean() 清除对应key的值。 重要的是要记住，这些状态对象仅用于状态的接口。状态不一定存储在内部，但可能驻留在磁盘或其他位置。要记住的第二件事是，从状态获得的值取决于input元素的key。因此，如果所涉及的key不同，则在一次调用用户函数时获得的值可能与另一次调用中的值不同。 必须使用StateDescriptor获得状态句柄，它保存了状态的名称（您可以创建多个状态，并且它们必须具有唯一的名称以便您可以引用它们），状态所持有的值的类型。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CountWindowAverage extends RichFlatMapFunction&lt;Tuple2&lt;Long, Long&gt;, Tuple2&lt;Long, Long&gt;&gt; &#123; /** * ValueState 句柄. The first field is the count, the second field a running sum. */ private transient ValueState&lt;Tuple2&lt;Long, Long&gt;&gt; sum; @Override public void flatMap(Tuple2&lt;Long, Long&gt; input, Collector&lt;Tuple2&lt;Long, Long&gt;&gt; out) throws Exception &#123; // 访问 state value Tuple2&lt;Long, Long&gt; currentSum = sum.value(); // 更新 count currentSum.f0 += 1; // 添加input值的第二个字段 currentSum.f1 += input.f1; //更新 state sum.update(currentSum); //如果 count 达到 2, 输出平均值并清除 state if (currentSum.f0 &gt;= 2) &#123; out.collect(new Tuple2&lt;&gt;(input.f0, currentSum.f1 / currentSum.f0)); sum.clear(); &#125; &#125; @Override public void open(Configuration config) &#123; ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt; descriptor = new ValueStateDescriptor&lt;&gt;( &quot;average&quot;, //state 名称 TypeInformation.of(new TypeHint&lt;Tuple2&lt;Long, Long&gt;&gt;() &#123;&#125;), // 类型信息 Tuple2.of(0L, 0L)); //如果没设置， state 默认值 sum = getRuntimeContext().getState(descriptor); &#125;&#125;//可以像在 streaming 程序中使用 (假如我们有 StreamExecutionEnvironment env)env.fromElements(Tuple2.of(1L, 3L), Tuple2.of(1L, 5L), Tuple2.of(1L, 7L), Tuple2.of(1L, 4L), Tuple2.of(1L, 2L)) .keyBy(0) .flatMap(new CountWindowAverage()) .print();// 输出为 (1,4) and (1,5) 该函数将计数和运行总和存储在ValueState中。一旦计数达到2，它将发出平均值并清除状态，以便我们重新开始0。 Using Managed Operator State有状态函数可以实现更通用的CheckpointedFunction接口去使用Managed Operator State。 CheckpointedFunctionCheckpointedFunction接口通过不同的再分配方案提供对非键控状态的访问。它需要实现两种方法：12void snapshotState(FunctionSnapshotContext context) throws Exception;void initializeState(FunctionInitializationContext context) throws Exception; 每当必须执行检查点时，snapshotState()都会被调用。每次初始化用户定义的函数时或者当函数从早期检查点恢复时,都会调用initializeState()。鉴于此，initializeState()不仅是初始化不同类型的状态，而且还用于状态恢复逻辑。 目前，Managed Operator State支持list-style(列表样式)。状态被认为是可序列化对象的列表，彼此独立，因此有资格在重新分配时进行再分配。根据状态访问方法，定义了以下再分配方案： Even-split redistribution：每个运算符返回一个状态元素列表。整个状态在逻辑上是所有列表的串联。在恢复-重新分配时，列表被平均分成与并行运算符一样多的子列表。每个运算符都会获得一个子列表，该子列表可以为空，也可以包含一个或多个元素。例如，如果使用并行性1，则运算符的检查点状态包含element1和element2；当将并行性增加到2时，element1可能最终在运算符实例0中，而element2将转到运算符实例1。 Union redistribution：每个运算符返回一个状态元素列表。整个状态在逻辑上是所有列表的串联。在恢复-重新分配时，每个运算符都会获得完整的状态元素列表。]]></content>
  </entry>
  <entry>
    <title><![CDATA[分布式数据流的轻量级异步快照]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%BC%82%E6%AD%A5%E5%BF%AB%E7%85%A7%2F</url>
    <content type="text"><![CDATA[本文章学习： Lightweight Asynchronous Snapshots for Distributed Dataﬂows 分布式状态流处理其被用于云部署并执行大规模连续计算，致力于高吞吐和低延迟。这依靠于周期性全局状态快照，他有两个缺点： 1. 由于影响了数据的摄入从而拖延了整体计算。 2.他们坚持了存储所有传输和算子的状态，从而导致更大的快照。 下面我们介绍Asynchronous Barrier Snapshotting (ABS，异步屏障快照)。 简介现有的所有分布式快照算法都把在通道中传输的记录或整个执行图中未处理的消息作为快照状态的一部分，这通常都不是必须的。而对于ABS来说，并不会停止流的操作，仅仅有一点小的开销。全局快照从理论上反映了执行图的整体状态或者其操作的一个特定实例的一个可能状态。 Apache Flink当一个用户需要执行一个应用程序时，所有的流数据运算符都被编译为一个执行图，原则上是一个有向图G = (T,E) ，其中顶点T表示任务，边E表示数据通道。运算符的每个实例都封装在各自的任务(subtask)上。M表示在并行执行期间由任务传输的所有记录的集合。每一个t∈T都是封装运算符实例的独立执行并且由以下内容组成： 1. 一组输入和输出管道 It,Ot ⊆ E; 2. 一个运算符状态st ; 3. 一个用户自定义函数(UDF)ft; 对于执行过程来说，每一个task都需要消耗输入记录，更新自己的状态，并根据UDF生成新的记录。换种说法是，对于每条记录 r∈ M被任务t∈T接收，并生成一个新的状态和一组根据UDF ft: 产生的新的输出D⊆M。 ABS我们定义了执行图G = (T,E)的一个全局快照G*=(T*, E*)作为所有任务和边的状态的集合，T由运算符状态st∈T组成，其中t∈T，E由通道状态e∈E组成，其中e∈E。 非环状执行图的异步屏障快照123456789101112131415161718192021221: upon event &lt;Init | input channels, output channels, fun, init state&gt; do // 事件发生&lt;触发操作 | 对象&gt;执行2: blocked inputs:= 0; //阻塞管道数初始化03: inputs:= input channels; //初始化input为所有input管道数4: outputs:= output channels; UDF := fun; //初始化output为所有输出管道数，初始化UDF5: 6: upon event &lt;receive | input,&lt;barrier&gt;&gt; do //从某个input接收到barrier7: if input != Nil then //当该input不是source时8: blocked inputs := blocked inputs ∪ &#123;input&#125;; //将已经收到barrier的管道并入 blocked inputs并阻塞，其他管道继续接收。9: trigger &lt;block | input&gt;; //触发阻塞barrier已经到达的管道10: if blocked_inputs = inputs then //已收到barrier的管道数等于所有input端的管道数，即所有barrier已经到达11: blocked_inputs:= 0; //置012: broadcast &lt;send | outputs,&lt;barrier&gt;&gt;; //向下游广播barrier13: trigger&lt;snapshot | state&gt;; //触发快照，保存算子state14: for each inputs as input 15: trigger &lt;unblock | input&gt;; //解锁所有input管道16: 17: 18: upon event &lt;receive | input, msg&gt; do//接受到正常消息时19: &#123;state&apos;, out_records&#125; := UDF(msg, state); //计算新的状态值和输出记录20: state := state&apos; ; //更新状态值21: for each out_records as &#123;output,out_record&#125; 22: trigger &lt;send | output, out_record&gt;; //向下游发送经算子计算后的输出记录。 当通道被阻塞时，所有消息被缓冲，不会被传递，直到取消阻塞。 task可以在诸如block, unblock and send messages等通道组件上触发操作，所有输出通道都支持broadcasting messages。 在source被注入的消息被解析为一个”Nil”输入通道。 中央协调员(JobManager中的一个进程)周期性的向所有source注入barrier。当一个source接受到barrier时，它会建立当前状态的快照并向下游广播。当非源算子接受到barrier时，它会阻塞该input channel，直到所有input都收到barrier后，该算子会保存当前状态的快照并向下游广播barrier。然后所有被block的input通道解除阻塞。完整的全局快照 G=(T, E) 将独自 由所有运算符的状态集T组成，其中E* = 0。 环状数据流的ABS在有向循环图中使用上面的算法时，因为算子会无期限的等待接受所有输入管道的barrier，将不会停止，会导致死锁。下面是适用于环状拓扑的ABS：1234567891011121314151617181920212223242526272829301: upon event &lt;Init | input_channels, backedge_channels, output_channels, fun, init_state&gt; do 2: state:= init_state; marked := 0; 3: inputs:= input_channels; logging:= False; 4: outputs:= output_channels; UDF := fun; 5: loop_inputs:= backedge_channels; 6: state_copy:= Nil; backup_log:= []; 7: 8: upon event &lt;receive | input, &lt;barrier&gt;&gt; do 9: marked := marked∪&#123;input&#125;; 10: regular := inputs\loop_inputs; 11: if input != Nil AND input / ∈loop inputs then 12: trigger &lt;block | input&gt;; 13: if ¬logging AND marked = regular then 14: state_copy:= state;logging:= True; 15: broadcast &lt;send | outputs, &lt;barrier&gt;&gt;; 16: for each inputs as input 17: trigger &lt;unblock | input&gt;; 18: 19: if marked = input_channels then 20: trigger &lt;snapshot | &#123;state_copy, backup_log&#125;&gt;; 21: marked := 0;logging:= False; 22: state_copy:= Nil;backup_log:= []; 23: 24: upon event &lt;receive|input, msg&gt; do 25: if logging AND node∈loop_inputs then 26: backup_log:= backup_log:: [input]; 27: &#123;state&apos;,out_records&#125;:= UDF(msg,state); 28: state:= state&apos;; 29: for each out_records as&#123;output,out_record&#125; 30: trigger &lt;send | output, out_record&gt;; 实现 在当前的实现中，blocked channels的所有输入数据被存储在磁盘上，而不是保存在内存中，以提高可伸缩性。 为了区分运算符状态和数据，我们引入了一个显式的OperatorState接口用于查询和更新状态。并且为Apache Flink的一些有状态的操作符(例如基于源的偏移量和聚合)提供了OperatorState实现。 结果ABS与全局同步快照算法比较 上述用于评估的执行拓扑图由六个不同运算符组成，并行度等于集群节点数目。source生成总计10亿条记录，在source实例间均匀分布。拓扑图中运算符的状态为每键(per-key)聚合和源偏移量。 在图2中, 我们描述了两个算法对基线 (Baseline) 的运行时影响。当快照的间隔较小时, 同步快照的性能影响尤为明显。这是由于系统花费更多的时间不处理任何数据, 以获取全局快照。ABS 对运行时的影响要低得多, 因为它连续运行而不阻塞总体执行, 同时保持相当稳定的吞吐量。对于更大的快照间隔, 同步算法的影响不那么显著, 因为它在我们的实验中以1-2 秒的时间运行, 同时让系统在其其余执行过程中以正常的吞吐量运转。 在图3中, 我们比较了运行 ABS 的拓扑的可伸缩性, 与基线的3秒快照间隔(无容错)相比。很明显, 基线作业和 ABS 都实现了线性可伸缩性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL 聚合函数与OVER]]></title>
    <url>%2F2018%2F09%2F06%2FOVER%2F</url>
    <content type="text"><![CDATA[group by与聚合函数(min()/max()/avg()/sum()等)在使用 group by 子句时，select列表中的所有列必须是聚合列(SUM,MIN/MAX,AVG等)或着是 group by 子句中包括的列。如果在select列表中使用聚合列，其中必须只包括聚合列，否则必须有一个 group by 子句。 窗口函数与聚合函数聚合函数返回的各个分组的结果，窗口函数则为每一行返回结果。窗口函数在和当前行相关的一组表行上执行计算。 这相当于一个可以由聚合函数完成的计算类型。但不同于常规的聚合函数， 使用的窗口函数不会导致行被分组到一个单一的输出行，行保留其独立的身份。 实例12select depname,empno, salary, avg(salary) over(partition by depname) from empsalary; 结果 depname empno salary avg develop 11 5200 5020.0000000000000000 develop 7 4200 5020.0000000000000000 develop 9 4500 5020.0000000000000000 develop 8 6000 5020.0000000000000000 develop 10 5200 5020.0000000000000000 personnel 5 3500 3700.0000000000000000 personnel 2 3900 3700.0000000000000000 sales 3 4800 4866.6666666666666667 sales 1 5000 4866.6666666666666667 sales 4 4800 4866.6666666666666667 前三列来自表格，第四列由avg得出，over使得将所有depname相同的行作为一个分区，求得其平均值赋给每一行。想一想如果使用group by会如何，按照depname分区？相同的depname行会被合并？select中的empno怎么办？ OVER1234OVER ( [ &lt;PARTITION BY clause&gt; ] [ &lt;ORDER BY clause&gt; ] ) partition by将查询结果集划分为分区。窗口函数分别应用于每个分区，并对每个分区重新开始计算。 order by定义结果集的每个分区中的行的逻辑顺序。也就是说，它指定执行窗口函数计算的逻辑顺序。 over() 与 group by：对于group by来说，只能聚合group by中未包含的列的值。然而，对于窗口聚合函数over()来说，你可以检索聚合和非聚合的值。 实例1下面是使用group by的实例，假设您需要计算每个值的总百分比，如果不使用窗口聚合函数，需要先生成聚合值表，然后把它加入原表：12345678910111213SELECT table.id， table.Value, table.Value * 100.0 / tab.totalValue AS percentValue FROM orig INNER JOIN ( SELECT id， SUM(value) AS totalValue FROM table GROUP BY id ) tab ON table.id = tab.id; 如果使用over():12345SELECT id, value, value * 100.0 / SUM(value) OVER (PARTITION BY id) AS percentValue FROM table; 实例2table： id name year color 1 Ford 2008 White 2 Chevy 2005 Green 3 Ford 2008 Yellow 查询：12345678SELECT id, name, year, color , COUNT(*) OVER (PARTITION BY year) AS count FROM tableORDER BY id; 结果： id name year color count 1 Ford 2008 White 2 2 Chevy 2005 Green 1 3 Ford 2008 Yellow 2 在没有group by的情况下进行了行的聚合，如果使用group by： 查询：123456789SELECT id, name, year, color , COUNT(*) AS count FROM table GROUP BY year, id, name, color ORDER BY id; 结果： id name year color count 1 Ford 2008 White 1 2 Chevy 2005 Green 1 3 Ford 2008 Yellow 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[简介]]></title>
    <url>%2F2018%2F09%2F02%2FIntroduction%2F</url>
    <content type="text"><![CDATA[这是***的个人博客。原文章地址: Essay]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
